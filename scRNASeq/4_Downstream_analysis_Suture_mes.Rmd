---
title: "suture_mes_mito_MAGIC_plot"
author: "Huan Liu"
date: "2025-03-05"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(
  message = TRUE,
  warning = FALSE,
  cache = TRUE,
  echo = TRUE,
  cache.lazy = FALSE)
```

This is an analysis and ploting script for Figure 4, searching for the features of DEGs in OG3 among different genotypes, which revealed the most striking difference among genotypes were related with mitochondria resperation, and a potential target CDK8.
"suture_mes_mito_MAGIC_harmony_20230329.rds" from MAGIC imputation was subjected for the downstream analysis in this script.
Pay attention to the cluster method, we finally adopted, is "k-mean", detailed recored in "5.3 k-mean".

# 1 Prepare data
## 1.1 Load packages and data
```{r, remove unwanted objects in the environment and load pacakges}

gc()
rm(list=ls())
.libPaths(c("/home/liuhuan/rpackage/", "/usr/local/lib/R/site-library"))
library(ggplot2)
library(Seurat)
library(SeuratObject)
library(RColorBrewer)
library(dplyr)
library(magrittr)
suture_mes_mito_MAGIC <- readRDS(file = "./SeuratObject/suture_mes_mito_MAGIC_harmony_20230329.rds")

Idents(suture_mes_mito_MAGIC) <- c("SCT_snn_res.0.6")
```

Inspect the data by umap plot

```{r, inspect suture_mes_mito_MAGIC}
DimPlot(suture_mes_mito_MAGIC, reduction = "umap", label = T)
```



We then check the distribution of mito genes.
```{r, marker for cluster mito percent,fig.height=6, fig.width=8}

FeaturePlot(suture_mes_mito_MAGIC, features = c("percent.mt"),
            cols = c("grey85",brewer.pal(9,"YlOrRd")),
            ncol=2, pt.size = 0.1, label=T)
```
We found even after the regression of the mito genes, we still can find the enrichment of mito genes in cluster 14 and cluster 15.  We removed them.
```{r, subset seurat object}
suture_mes_mito_MAGIC <- subset(suture_mes_mito_MAGIC, idents=c(0:13))
```
Check the distribution of mito percentage again.
```{r, marker for cluster mito percent,fig.height=6, fig.width=10}

FeaturePlot(suture_mes_mito_MAGIC, features = c("percent.mt"),
            cols = c("grey85",brewer.pal(9,"YlOrRd")),
            ncol=2, pt.size = 0.1,
            label=T)
```

```{r, umap plot for cluster,fig.height=6, fig.width=8}
DimPlot(suture_mes_mito_MAGIC, reduction = "umap", label = T)

```
## 1.2 Marker genes identification
Identification of marker genes
refer to `https://github.com/satijalab/seurat/issues/2115` Perform DE using RNA rather than SCT

```{r, generally find marker genes}
Idents(suture_mes_mito_MAGIC) <- c("SCT_snn_res.0.6")

DefaultAssay(suture_mes_mito_MAGIC) <- "RNA"
suture_mes_mito_MAGIC <- NormalizeData(suture_mes_mito_MAGIC)
all.genes <- rownames(suture_mes_mito_MAGIC)
suture_mes_mito_MAGIC <- ScaleData(suture_mes_mito_MAGIC, features = all.genes)
suture_mes_mito_MAGIC_markers <- FindAllMarkers(object = suture_mes_mito_MAGIC, only.pos = TRUE, 
                               min.pct = 0.25, thresh.use = 0.25) #identify positive marker genes 
top10 <- suture_mes_mito_MAGIC_markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_log2FC) # You may change n=10 to other number to get top_n genes as you wish.
```

```{r, output tables for marker genes}
write.csv(suture_mes_mito_MAGIC_markers, file = "./OutputTable/suture_mes_mito_MAGIC_markers_20230328.csv", row.names = FALSE)
write.csv(top10, file = "./OutputTable/suture_mes_mito_MAGIC_top10_markers_20230328.csv", row.names = FALSE)


```

Plot heatmap for marker genes
```{r, heatmapplot, fig.width=10, fig.height=18 }

DoHeatmap(suture_mes_mito_MAGIC, features = top10$gene)
ggsave("./OutputFigure/suture_mes_mito_MAGIC_markers_top10_20230328.pdf", device = "pdf",#adjust filename accordingly
       width = 30, #adjust according to the display of output
       height = 55, #adjust according to the display of output
       units = "cm")

```

## 1.3 Marker genes plot
Here, we will first plot marker genes 
```{r, marker for cluster 0,fig.height=4, fig.width=5}
FeaturePlot(suture_mes_mito_MAGIC, features = c("Sfrp2","Tac1",
                                          "Scx","Igfbp3"),
            cols = c("grey85",brewer.pal(9,"YlOrRd")),
            ncol=2, pt.size = 0.1)

```
Thus, we name cluster 0 as ligament like cells (LIG)

```{r, marker for cluster 1,fig.height=4, fig.width=5}
FeaturePlot(suture_mes_mito_MAGIC, features = c("Postn","Mmp13","Npnt","Podnl1"),
            cols = c("grey85",brewer.pal(9,"YlOrRd")),
            ncol=2, pt.size = 0.1)
```
With Mmp13 and Podnl1 highly enriched in osteogenic cluster, we name it as "OG1"

```{r, marker for cluster 2,fig.height=4, fig.width=5}
FeaturePlot(suture_mes_mito_MAGIC, features = c("Matn4","Cpz","Nppc","Fmod"),
            cols = c("grey85",brewer.pal(9,"YlOrRd")),
            ncol=2, pt.size = 0.1)
```
With highly enrichment of Matn4 and some overlap of Nppc, cluster2 must belong to outer menigeal population, making it as "MG1"


```{r, marker for cluster 3,fig.height=4, fig.width=5}
FeaturePlot(suture_mes_mito_MAGIC, features = c("Crabp2","Gsta4","Slc4a10","Fxyd5"),
            cols = c("grey85",brewer.pal(9,"YlOrRd")),
            ncol=2, pt.size = 0.1)
```
With highly enrichment of Crabp2 and Fxyd5, cluster 3 belongs to inner menigeal population, making it as "MG2".

```{r, marker for cluster 4,fig.height=4, fig.width=5}
FeaturePlot(suture_mes_mito_MAGIC, features = c("Crip1","Tnn","Npnt","Tnc"),
            cols = c("grey85",brewer.pal(9,"YlOrRd")),
            ncol=2, pt.size = 0.1)
```
With partially overlap of Npnt, Tnn and Tnc, we term this cluster as "OG2".

```{r, marker for cluster 5,fig.height=4, fig.width=5}
FeaturePlot(suture_mes_mito_MAGIC, features = c("Ppp1r10","Wsb1","Rasl11b","Irf1"),
            cols = c("grey85",brewer.pal(9,"YlOrRd")),
            ncol=2, pt.size = 0.1)
```
With partial overlap with Matn4, we term this cluster as "MG3".


```{r, marker for cluster 6,fig.height=4, fig.width=5}
FeaturePlot(suture_mes_mito_MAGIC, features = c("Stmn1","Hmgb2","Top2a","Mki67"),
            cols = c("grey85",brewer.pal(9,"YlOrRd")),
            ncol=2, pt.size = 0.1)
```

With specific enrichment of Mki67 and Top2a, which is highly associated with proliferation, we term this as "PO".

```{r, marker for cluster 7,fig.height=4, fig.width=5}
FeaturePlot(suture_mes_mito_MAGIC, features = c("Ccl11","Il6","Igf1","Col4a1"),
            cols = c("grey85",brewer.pal(9,"YlOrRd")),
            ncol=2, pt.size = 0.1)
```
With highly overlap expression pattern of Igf1, we term this cluster as "MG4".

```{r, marker for cluster 8,fig.height=4, fig.width=5}
FeaturePlot(suture_mes_mito_MAGIC, features = c("Bglap","Ibsp","Dmp1","Ifitm5"),
            cols = c("grey85",brewer.pal(9,"YlOrRd")),
            ncol=2, pt.size = 0.1)
```
With a relatively terminal differentiation marker for osteoblasts, Dmp1 and Ifitm5, we term this cluster as "OG3".

```{r, marker for cluster 9,fig.height=4, fig.width=5}
FeaturePlot(suture_mes_mito_MAGIC, features = c("Pi16","Ly6a","Clc3b"),
            cols = c("grey85",brewer.pal(9,"YlOrRd")),
            ncol=2, pt.size = 0.1)
```
With Pi16 and Ly6a, markers for ectocranial population, we term this cluster as "EC".

```{r, marker for cluster 10,fig.height=4, fig.width=5}
FeaturePlot(suture_mes_mito_MAGIC, features = c("Col2a1","Mia","Mmp9","Acan"),
            cols = c("grey85",brewer.pal(9,"YlOrRd")),
            ncol=2, pt.size = 0.1)
```
This cluster were termed as "Chondro" for chondrogenesis.

```{r, marker for cluster 11,fig.height=4, fig.width=5}
FeaturePlot(suture_mes_mito_MAGIC, features = c("Rgs5","Procr","Myh11","Gm13889"),
            cols = c("grey85",brewer.pal(9,"YlOrRd")),
            ncol=2, pt.size = 0.1)
```
This cluster were termed as "Peri" for pericytes.

```{r, marker for cluster 5,fig.height=4, fig.width=5}
FeaturePlot(suture_mes_mito_MAGIC, features = c("Tnmd","Matn4",
                                          "Scx","Cilp2"),
            cols = c("grey85",brewer.pal(9,"YlOrRd")),
            ncol=2, pt.size = 0.1)
```

## 1.4 Celltype 
```{r, rename cluster}
new.cluster.ids <- c("LIG", #Cluster 0 
                     "OG1", #Cluster 1 
                     "OG2", #Cluster 2 
                     "MG1", #Cluster 3 
                     "MG3", #Cluster 4 
                     "OG0", #Cluster 5 
                     "MG2", #Cluster 6 
                     "PO", #Cluster 7 
                     "MG5", #Cluster 8 
                     "MG4", #Cluster 9 
                     "OG3", #Cluster 10 
                     "EC", #Cluster 11
                     "Chondro", #Cluster 12
                     "Peri", #Cluster 13
                     "removed", #Cluster 14 with high mito
                     "removed" #Cluster 15 with high mito
                     )
Idents(suture_mes_mito_MAGIC) <- c("SCT_snn_res.0.6")
suture_mes_mito_MAGIC@meta.data$seurat_clusters <-suture_mes_mito_MAGIC@meta.data$SCT_snn_res.0.6
suture_mes_mito_MAGIC@meta.data$celltype<- suture_mes_mito_MAGIC@meta.data$seurat_clusters
levels(suture_mes_mito_MAGIC@meta.data$celltype) <- new.cluster.ids
```

```{r,draft plot for celltype}
DimPlot(suture_mes_mito_MAGIC, reduction = "umap", label = T, group.by = "celltype")
```

```{r, initial plots after celltype}
Idents(suture_mes_mito_MAGIC) <- c("celltype")
#group_by_cluster
plot1 = DimPlot(suture_mes_mito_MAGIC, reduction = "umap", label = T)
# group_by_sample
plot2 = DimPlot(suture_mes_mito_MAGIC, reduction = "umap", group.by = "celltype")
plot3 = DimPlot(suture_mes_mito_MAGIC, reduction = "umap", split.by  = "orig.ident")
# combine
plotc <- plot1 + plot2
ggsave("./OutputFigure/suture_mes_mito_MAGIC_umap_celltype.png", plot = plotc, width = 10, height = 5)
plot3
ggsave("./OutputFigure/suture_mes_mito_MAGIC_umap_celltype_split.png", plot = plot3, width = 20, height = 5) # You may set the parameters, especially the "width". Usually each plot will take about 5.5 unit.

DimPlot(suture_mes_mito_MAGIC, reduction = "umap", label = T)
DimPlot(suture_mes_mito_MAGIC, reduction = "umap", group.by = "celltype")

```

```{r, output integrated data}
saveRDS(suture_mes_mito_MAGIC, file = "./SeuratObject/suture_mes_mito_MAGIC_harmony_renamed_20250420.rds")
```



## 2 Dotplot for celltype
Load data and packages
```{r load of packages and setup of the environment 1}
gc()
rm(list=ls())
.libPaths(c("/home/liuhuan/rpackage/", "/usr/local/lib/R/site-library"))
library(ggplot2)
library(Seurat)
library(SeuratObject)

suture_mes_mito_MAGIC <- readRDS(file = "./SeuratObject/suture_mes_mito_MAGIC_harmony_renamed_20250420.rds")


library(data.table)
library(scales)
library(plotly)
library(ggplot2)
library(slingshot)
library(magrittr)
library(dplyr)
#library(tidyverse)
library(cowplot)
library(gridExtra)
library(viridis)
library(readr)
library(Hmisc)
library(ggpubr)
library(rsample)
library(tidymodels)
library(scales)
library(scCustomize)
library(pheatmap)
library(RColorBrewer)
set.seed(12)
theme_set(theme_bw())




```


```{r, check the order of celltype for display}
levels(suture_mes_mito_MAGIC@meta.data$celltype)
```


We want to reorder the celltype, to make plot more apealing.
```{r, re-order celltype}
suture_mes_mito_MAGIC$celltype <- factor(suture_mes_mito_MAGIC$celltype, levels = c("Peri","Chondro","EC","LIG","PO","OG0","OG1","OG2","OG3","MG1", "MG2", "MG3", "MG4","MG5","removed")) 
levels(suture_mes_mito_MAGIC$celltype)
```

```{r}
DimPlot(suture_mes_mito_MAGIC, reduction = "umap", label = T)
ggsave("./OutputFigure/suture_mes_mito_MAGIC_celltype_UMAP_labeled.pdf", device = "pdf", width = 4, height = 3)
DimPlot(suture_mes_mito_MAGIC, reduction = "umap", group.by = "celltype")
ggsave("./OutputFigure/suture_mes_mito_MAGIC_celltype_UMAP.pdf", device = "pdf", width = 4, height = 3)
```

```{r,dotplot for cell types,fig.height=4, fig.width=12}
genes_to_check_mes <- c("Rgs5","Procr","Myh11","Gm13889",  #Peri
                        "Col2a1","Mia","Mmp9","Acan", #Chondro
                        "Pi16","Ly6a","Clc3b", #EC
                        "Sfrp2","Tac1", "Scx","Igfbp3",#LIG
                        "Stmn1","Hmgb2","Top2a","Mki67", #PO
                        "Postn","Mmp13","Npnt","Podnl1", #OG1
                        "Crip1","Tnn","Npnt","Tnc", #OG2
                        "Bglap","Ibsp","Dmp1","Ifitm5", #OG3
                        "Matn4","Cpz","Nppc","Fmod", #MG1
                        "Crabp2","Gsta4","Slc4a10","Fxyd5",#MG2
                        "Ppp1r10","Wsb1","Rasl11b","Irf1", #MG3
                        "Ccl11","Il6","Igf1","Col4a1" #MG4
                        )


DotPlot(suture_mes_mito_MAGIC, features = unique(genes_to_check_mes),group.by = "celltype")+RotatedAxis()+
  scale_x_discrete("")+scale_y_discrete("")
ggsave("./OutputFigure/suture_mes_mito_MAGIC_harmony_dotplot_celltype_0430.pdf",width = 15,height = 6)

```



```{r,dotplot for cell types blue red color,fig.height=4, fig.width=12}
DotPlot(suture_mes_mito_MAGIC, features = unique(genes_to_check_mes),
        cols = c("lightgrey","red"),col.min = 0, col.max = 3,
        group.by = "celltype")+
  RotatedAxis()+
  scale_x_discrete("")+
  scale_y_discrete("")
ggsave("./OutputFigure/suture_mes_mito_MAGIC_harmony_dotplot_celltype_red_0430.pdf",width = 15,height = 6)


```
```{r, dotplot with different celltype, green and yellow,fig.height=6, fig.width=15}
Idents(suture_mes_mito_MAGIC) <- suture_mes_mito_MAGIC$celltype
DotPlot(suture_mes_mito_MAGIC, features=unique(genes_to_check_mes))+
  theme_bw()+
  theme(panel.grid = element_blank(), axis.text.x = element_text(angle=45,hjust = 0.5, vjust = 0.5))+
  labs(x=NULL, y=NULL)+ guides(size = guide_legend(order=3))+
  scale_color_gradientn(values = seq(0,1,0.2), colours = c('#330066', '#336699','#66CC66','#FFCC33'))
ggsave("./OutputFigure/suture_mes_mito_MAGIC_harmony_dotplot_celltype_green_0430.pdf",width = 15,height = 6)
```
```{r, split by group}
suture_mes_mito_MAGIC_object_list <- SplitObject(suture_mes_mito_MAGIC, split.by = "group")
suture_mes_mito_MAGIC_SAG <- suture_mes_mito_MAGIC_object_list$SAG
suture_mes_mito_MAGIC_PF <- suture_mes_mito_MAGIC_object_list$PF
```


```{r}
saveRDS(suture_mes_mito_MAGIC_SAG, file = "./SeuratObject/suture_mes_mito_MAGIC_harmony_renamed_SAG_0430.rds")

saveRDS(suture_mes_mito_MAGIC_PF, file = "./SeuratObject/suture_mes_mito_MAGIC_harmony_renamed_PF_0430.rds")
```

```{r}
gc()
rm(list=ls())
```

# 3 Cell proportion
## 3.1 PF
### 3.1.1 load package
```{r load of packages and setup of the environment 1}
gc()
rm(list=ls())
.libPaths(c("/home/liuhuan/rpackage/", "/usr/local/lib/R/site-library"))
library(ggplot2)
library(Seurat)
library(SeuratObject)

suture_mes_mito_MAGIC_PF <- readRDS(file = "./SeuratObject/suture_mes_mito_MAGIC_harmony_renamed_PF_0430.rds")


library(data.table)
library(scales)
library(plotly)
library(ggplot2)
library(slingshot)
library(magrittr)
library(dplyr)
#library(tidyverse)
library(cowplot)
library(gridExtra)
library(viridis)
library(readr)
library(Hmisc)
library(ggpubr)
library(rsample)
library(tidymodels)
library(scales)
library(scCustomize)
library(pheatmap)
library(RColorBrewer)
set.seed(12)
theme_set(theme_bw())


```

```{r, change levels}
suture_mes_mito_MAGIC_PF$celltype <- factor(suture_mes_mito_MAGIC_PF$celltype, levels = c("Peri","Chondro","EC","LIG","PO","OG0","OG1","OG2","OG3","MG1", "MG2", "MG3", "MG4","MG5","removed")) 
levels(suture_mes_mito_MAGIC_PF$celltype)
```

```{r}
DimPlot(suture_mes_mito_MAGIC_PF, reduction = "umap", label = T)
DimPlot(suture_mes_mito_MAGIC_PF, reduction = "umap", group.by = "celltype")
```




```{r,prepare function for cell percentage}
# --- Ensure necessary libraries are loaded ---
# install.packages(c("Seurat", "ggplot2", "data.table", "dplyr", "forcats", "reshape2")) # If needed, uncomment and run to install
library(Seurat)
library(ggplot2)
library(data.table)
library(dplyr)
library(forcats)
library(reshape2) # melt function is in this package (although data.table::melt also works)

#' @title Calculate and Plot Cell Proportions from Seurat Object Metadata
#'
#' @description This function takes a Seurat object, extracts metadata, calculates cell counts
#'              and percentages grouped by 'orig.ident' and a specified metadata column,
#'              saves the results to CSV files, and generates several summary plots.
#'
#' @param seurat_obj A Seurat object.
#' @param group_by_metadata A string specifying the metadata column name to group cells by (e.g., "celltype", "seurat_clusters").
#' @param output_prefix A string used as a prefix for all output file names. Helps in organizing outputs.
#' @param output_dir_table Path to the directory where CSV tables will be saved. Defaults to "./OutputTable".
#' @param output_dir_figure Path to the directory where PDF plots will be saved. Defaults to "./OutputFigure".
#' @param relevel_vector An optional character vector specifying the desired order of levels for the `group_by_metadata` factor on the plot's x-axis. If NULL (default), the default factor ordering is used.
#'
#' @return Invisibly returns the long-format data table containing percentages (`split_count_mut_melt`).
#'
#' @importFrom Seurat Idents<-
#' @import data.table
#' @import dplyr
#' @import ggplot2
#' @import forcats
#' @import reshape2
#'
#' @examples
#' \dontrun{
#' # Assume you have a Seurat object named 'my_seurat_object'
#' # and you want to group by 'celltype' metadata
#' calculate_and_plot_proportions(
#'   seurat_obj = my_seurat_object,
#'   group_by_metadata = "celltype",
#'   output_prefix = "my_analysis_celltype",
#'   relevel_vector = c("TypeA", "TypeC", "TypeB") # Optional ordering
#' )
#'
#' # Group by 'seurat_clusters'
#' calculate_and_plot_proportions(
#'   seurat_obj = my_seurat_object,
#'   group_by_metadata = "seurat_clusters",
#'   output_prefix = "my_analysis_clusters"
#' )
#' }

calculate_and_plot_proportions <- function(seurat_obj,
                                           group_by_metadata,
                                           output_prefix,
                                           output_dir_table = "./OutputTable",
                                           output_dir_figure = "./OutputFigure",
                                           relevel_vector = NULL) {

  # --- Parameter validation ---
  if (!inherits(seurat_obj, "Seurat")) {
    stop("Input 'seurat_obj' must be a Seurat object.")
  }
  if (!is.character(group_by_metadata) || length(group_by_metadata) != 1) {
    stop("'group_by_metadata' must be a single string.")
  }
  if (!group_by_metadata %in% colnames(seurat_obj@meta.data)) {
    stop(paste("Metadata column", shQuote(group_by_metadata), "not found in the Seurat object."))
  }
  if (!is.character(output_prefix) || length(output_prefix) != 1) {
    stop("'output_prefix' must be a single string.")
  }
  if (!dir.exists(output_dir_table)) {
      message("Creating output table directory: ", output_dir_table)
      dir.create(output_dir_table, recursive = TRUE)
  }
   if (!dir.exists(output_dir_figure)) {
      message("Creating output figure directory: ", output_dir_figure)
      dir.create(output_dir_figure, recursive = TRUE)
  }


  # --- 1. Extract and calculate cell counts ---
  message("Step 1: Calculating cell counts...")
  # Set Idents (although not directly used for counting in this specific workflow, but consistent with original code)
  Idents(seurat_obj) <- seurat_obj[[group_by_metadata, drop = TRUE]]

  ## Extract metadata
  md <- as.data.table(seurat_obj@meta.data)

  ## Calculate cell counts by "orig.ident" and specified metadata column
  split_count_long <- md[, .N, by = c("orig.ident", group_by_metadata)]
  setnames(split_count_long, "N", "Number") # Rename count column

  ## Convert to wide format (dcast)
  # Build dcast formula
  formula_dcast <- as.formula(paste("orig.ident ~", group_by_metadata))
  split_count_wide <- dcast(split_count_long, formula_dcast, value.var = "Number", fill = 0) # fill=0 replaces NA

  ## Convert back to long format (melt) - for plotting and saving
  split_count_melt <- melt(split_count_wide,
                           id.vars = "orig.ident",
                           variable.name = group_by_metadata, # Use input parameter
                           value.name = "Number")
  # Ensure the group_by_metadata column after melt is factor type
  split_count_melt[[group_by_metadata]] <- as.factor(split_count_melt[[group_by_metadata]])


  ## Save original counts (long format)
  count_filename_csv <- file.path(output_dir_table, paste0(output_prefix, "_cell_number_", group_by_metadata, ".csv"))
  message("Saving raw counts (long format) to: ", count_filename_csv)
  fwrite(split_count_melt, file = count_filename_csv, row.names = FALSE)

  # --- 2. Plot proportional chart of original counts ---
  message("Step 2: Generating count proportion plot...")

  # Factor level reordering (if provided)
  if (!is.null(relevel_vector)) {
    message("Releveling factor: ", group_by_metadata)
    # Check if all provided levels are in the data
    current_levels <- levels(split_count_melt[[group_by_metadata]])
    if (!all(relevel_vector %in% current_levels)) {
        warning("Some levels in 'relevel_vector' are not present in the data for column '", group_by_metadata, "'. Proceeding with available levels.")
        relevel_vector <- intersect(relevel_vector, current_levels)
    }
     if (length(relevel_vector) > 0) {
       split_count_melt[[group_by_metadata]] <- fct_relevel(split_count_melt[[group_by_metadata]], relevel_vector)
     } else {
        warning("No valid levels remaining in 'relevel_vector' after checking against data. Skipping releveling.")
     }
  }

  p1 <- ggplot(split_count_melt, aes(fill = orig.ident, x = .data[[group_by_metadata]], y = Number)) +
    geom_bar(position = "fill", stat = "identity") +
    ggtitle(paste("Proportion of cells per", group_by_metadata, "across identities (raw counts)")) +
    xlab(group_by_metadata) +
    ylab("Proportion of cells") +
    theme_minimal(base_size = 12) + # Use a slightly cleaner theme
    theme(
        plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1), # Rotate X-axis labels to prevent overlap
        legend.position = "bottom" # Place legend at bottom
        )

  plot_filename_p1 <- file.path(output_dir_figure, paste0(output_prefix, "_Percentage_cell_in_each_", group_by_metadata, "_unnormalized.pdf"))
  message("Saving count proportion plot to: ", plot_filename_p1)
  ggsave(plot_filename_p1, plot = p1, height = 5, width = max(7.5, length(levels(split_count_melt[[group_by_metadata]]))*0.5 + 2 )) # Dynamic width

  # --- 3. Calculate percentages within each orig.ident ---
  message("Step 3: Calculating percentages within each orig.ident...")

  # Use data.table chaining operations to calculate percentages more efficiently
  # Start from long format counts
  split_count_long[, total_per_ident := sum(Number), by = orig.ident] # Calculate total for each orig.ident
  split_count_long[, Percentage := fifelse(total_per_ident > 0, (Number / total_per_ident) * 100, 0), by = orig.ident] # Calculate percentage, handle cases where total is 0

  # Extract long format percentage data for saving and plotting
  split_count_mut_melt <- split_count_long[, .(orig.ident, get(group_by_metadata), Percentage)]
  setnames(split_count_mut_melt, "V2", group_by_metadata) # Rename column name generated by get()
  # Ensure factor type and order are consistent with previous
  split_count_mut_melt[[group_by_metadata]] <- factor(split_count_mut_melt[[group_by_metadata]], levels = levels(split_count_melt[[group_by_metadata]]))


  # Create wide format percentage data for saving
  formula_dcast_perc <- as.formula(paste("orig.ident ~", group_by_metadata))
  split_count_mut_wide <- dcast(split_count_mut_melt, formula_dcast_perc, value.var = "Percentage", fill = 0)

  ## Save wide format percentage table
  perc_wide_filename_csv <- file.path(output_dir_table, paste0(output_prefix, "_cell_percentage_", group_by_metadata, "_unmelt.csv"))
  message("Saving percentages (wide format) to: ", perc_wide_filename_csv)
  fwrite(split_count_mut_wide, file = perc_wide_filename_csv, row.names = FALSE)

  ## Save long format percentage table
  perc_long_filename_csv <- file.path(output_dir_table, paste0(output_prefix, "_cell_percentage_", group_by_metadata, ".csv"))
  message("Saving percentages (long format) to: ", perc_long_filename_csv)
  fwrite(split_count_mut_melt, file = perc_long_filename_csv, row.names = FALSE)

  # --- 4. Plot percentage charts ---
  message("Step 4: Generating percentage plots...")

  ## 4a. Percentage stacked bar chart (filled by group, showing proportions) - Note this will look the same as p1 visually
  p2 <- ggplot(split_count_mut_melt, aes(fill = orig.ident, x = .data[[group_by_metadata]], y = Percentage)) +
    geom_bar(position = "fill", stat = "identity") + # position="fill" will recalculate proportions
    ggtitle(paste("Proportion of cells per", group_by_metadata, "across identities (normalized proportions)")) +
    xlab(group_by_metadata) +
    ylab("Proportion of cells") +
    theme_minimal(base_size = 12) +
    theme(
        plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        legend.position = "bottom"
        )

  plot_filename_p2 <- file.path(output_dir_figure, paste0(output_prefix, "_Percentage_cell_in_each_", group_by_metadata, "_normalized_fill.pdf"))
  message("Saving percentage proportion plot (fill) to: ", plot_filename_p2)
  ggsave(plot_filename_p2, plot = p2, height = 5, width = max(7.5, length(levels(split_count_mut_melt[[group_by_metadata]]))*0.5 + 2 ))

  ## 4b. Percentage stacked bar chart (directly showing calculated percentages)
  # Using geom_col equivalent to geom_bar(stat="identity")
  p3 <- ggplot(split_count_mut_melt, aes(x = .data[[group_by_metadata]], y = Percentage, fill = orig.ident)) +
    geom_col(color = "black") + # Add black borders
    ggtitle(paste("Percentage of cells within each", group_by_metadata)) +
    xlab(group_by_metadata) +
    ylab("Percentage (%)") +
    theme_bw(base_size = 12) +
    theme(
        panel.grid = element_blank(), # Remove background grid lines
        plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        legend.position = "bottom"
        )

  plot_filename_p3 <- file.path(output_dir_figure, paste0(output_prefix, "_Percentage_cell_in_each_", group_by_metadata, "_normalized_stack.pdf"))
  message("Saving percentage stacked plot to: ", plot_filename_p3)
  ggsave(plot_filename_p3, plot = p3, height = 5, width = max(7.5, length(levels(split_count_mut_melt[[group_by_metadata]]))*0.5 + 2 ))


  ## 4c. Percentage side-by-side bar chart (Dodge)
  p4 <- ggplot(split_count_mut_melt, aes(x = .data[[group_by_metadata]], y = Percentage, fill = orig.ident)) +
    geom_col(color = "black", position = position_dodge(preserve = "single")) + # Use position_dodge and preserve single bar positions
    ggtitle(paste("Percentage of cells within each", group_by_metadata)) +
    xlab(group_by_metadata) +
    ylab("Percentage (%)") +
    theme_bw(base_size = 12) +
    theme(
        panel.grid = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        legend.position = "bottom"
        )

  plot_filename_p4 <- file.path(output_dir_figure, paste0(output_prefix, "_Percentage_cell_in_each_", group_by_metadata, "_normalized_dodge.pdf"))
  message("Saving percentage dodged plot to: ", plot_filename_p4)
  # Dodge plots usually need wider space
  ggsave(plot_filename_p4, plot = p4, height = 5, width = max(8, length(levels(split_count_mut_melt[[group_by_metadata]])) * length(unique(split_count_mut_melt$orig.ident)) * 0.2 + 3))

  message("Function finished successfully!")

  # Return long format percentage data frame for continued use in R environment
  invisible(split_count_mut_melt)
}

# --- How to use ---
# Assume your Seurat object is called suture_mes_mito_MAGIC_PF
# and you want to group by "celltype"

# Example usage 1: Basic usage
# calculate_and_plot_proportions(
#   seurat_obj = suture_mes_mito_MAGIC_PF,
#   group_by_metadata = "celltype",
#   output_prefix = "suture_mes_mito_MAGIC_PF_harmony_celltype" # Provide a filename prefix
# )

# Example usage 2: Specify output directories and factor ordering
# my_celltype_order <- c("Peri","Chondro","EC","LIG","PO","OG1","OG2","OG3","MG1", "MG2", "MG3", "MG4") # Define your order
# calculate_and_plot_proportions(
#   seurat_obj = suture_mes_mito_MAGIC_PF,
#   group_by_metadata = "celltype",
#   output_prefix = "suture_mes_mito_MAGIC_PF_harmony_celltype_ordered",
#   output_dir_table = "./CustomTables",  # Custom table output directory
#   output_dir_figure = "./CustomFigures", # Custom figure output directory
#   relevel_vector = my_celltype_order       # Pass in ordering vector
# )

# Example usage 3: Group by different metadata, such as 'seurat_clusters'
# calculate_and_plot_proportions(
#   seurat_obj = suture_mes_mito_MAGIC_PF,
#   group_by_metadata = "seurat_clusters",
#   output_prefix = "suture_mes_mito_MAGIC_PF_harmony_clusters"
# )
```
```{r,DPA-based percentage comparison}
# --- Ensure necessary libraries are loaded ---
# install.packages(c("Seurat", "data.table", "dplyr", "tibble")) # If needed
library(Seurat)
library(data.table)
library(dplyr)
library(tibble) # For remove_rownames and column_to_rownames

#' @title Perform Differential Cell Proportion Analysis
#'
#' @description This function automates the process of calculating cell counts per group
#'              and condition, performing pairwise differential proportion tests using
#'              functions from an external script (e.g., diffprop_functions.R), and
#'              saving the results across a range of error probabilities.
#'
#' @param seurat_obj A Seurat object.
#' @param group_by_metadata A string specifying the metadata column name to group cells by (e.g., "celltype"). This column defines the populations whose proportions are compared.
#' @param comparisons A list of character vectors. Each vector must have length 2,
#'                   in the format `c("condition_treatment", "condition_control")`.
#'                   These values must correspond to unique values in the 'orig.ident'
#'                   column of the Seurat object's metadata.
#'                   Example: `list(c("DM_PF", "WT_PF"), c("KO_PF", "WT_PF"))`.
#' @param error_probabilities A numeric vector of error probabilities (p) to test in `generateNull`.
#'                            Defaults to `c(0.5, 0.4, 0.3, 0.25, 0.2, 0.15, 0.1, 0.05)`.
#' @param n_iterations An integer specifying the number of iterations ('n') for `generateNull`.
#'                     Defaults to 100000.
#' @param diffprop_script_path The file path to the R script containing the `generateNull`
#'                             and `two.class.test` functions. Defaults to "diffprop_functions.R".
#' @param output_prefix A string used as a prefix for all output file names.
#' @param output_dir_table Path to the directory where CSV tables will be saved. Defaults to "./OutputTable".
#'
#' @return A list containing the results tables (p-values) for each comparison across the specified error probabilities. Each element in the list corresponds to a comparison.
#'
#' @importFrom Seurat Idents<-
#' @import data.table
#' @import dplyr
#' @import tibble
#'
#' @export
#'
#' @examples
#' \dontrun{
#' # Assume 'suture_mes_mito_MAGIC_PF' is your Seurat object
#' # Assume 'diffprop_functions.R' is in your working directory or accessible path
#'
#' # Define the comparisons you want to make
#' my_comparisons <- list(
#'   c("DM_PF", "WT_PF"),
#'   c("KO_PF", "WT_PF"),
#'   c("Runx2_PF", "WT_PF"),
#'   c("DM_PF", "Runx2_PF"),
#'   c("KO_PF", "Runx2_PF"),
#'   c("DM_PF", "KO_PF")
#' )
#'
#' # Run the analysis
#' results_list <- run_differential_proportion_analysis(
#'   seurat_obj = suture_mes_mito_MAGIC_PF,
#'   group_by_metadata = "celltype",
#'   comparisons = my_comparisons,
#'   output_prefix = "suture_mes_mito_MAGIC_PF_DPA"
#' )
#'
#' # Access results for a specific comparison, e.g., DM_PF vs WT_PF
#' # dm_vs_wt_results <- results_list[["DM_PF_vs_WT_PF"]]
#' # print(dm_vs_wt_results)
#' }
run_differential_proportion_analysis <- function(
    seurat_obj,
    group_by_metadata,
    comparisons,
    error_probabilities = c(0.5, 0.4, 0.3, 0.25, 0.2, 0.15, 0.1, 0.05),
    n_iterations = 100000,
    diffprop_script_path = "diffprop_functions.R",
    output_prefix,
    output_dir_table = "./OutputTable"
) {

  # --- Input Validation ---
  if (!inherits(seurat_obj, "Seurat")) {
    stop("Input 'seurat_obj' must be a Seurat object.")
  }
  if (!is.character(group_by_metadata) || length(group_by_metadata) != 1) {
    stop("'group_by_metadata' must be a single string.")
  }
  if (!group_by_metadata %in% colnames(seurat_obj@meta.data)) {
    stop("Metadata column ", shQuote(group_by_metadata), " not found in the Seurat object.")
  }
  if (!is.list(comparisons) || length(comparisons) == 0) {
      stop("'comparisons' must be a non-empty list.")
  }
  if (!all(sapply(comparisons, function(x) is.character(x) && length(x) == 2))) {
      stop("Each element in 'comparisons' must be a character vector of length 2: c('treatment', 'control').")
  }
  all_conditions <- unique(unlist(comparisons))
  if (!all(all_conditions %in% unique(seurat_obj$orig.ident))) {
      missing_cond <- setdiff(all_conditions, unique(seurat_obj$orig.ident))
      stop("The following conditions specified in 'comparisons' are not found in seurat_obj$orig.ident: ",
           paste(missing_cond, collapse=", "))
  }
  if (!file.exists(diffprop_script_path)) {
    stop("Differential proportion functions script not found at: ", diffprop_script_path)
  }
   if (!dir.exists(output_dir_table)) {
      message("Creating output table directory: ", output_dir_table)
      dir.create(output_dir_table, recursive = TRUE)
  }
  if (!is.character(output_prefix) || length(output_prefix) != 1) {
    stop("'output_prefix' must be a single string.")
  }


  # --- 1. Source the differential proportion functions ---
  message("Sourcing functions from: ", diffprop_script_path)
  source(diffprop_script_path)
  # Check if functions are loaded (optional but good practice)
  if (!exists("generateNull") || !exists("two.class.test")) {
      stop("Functions 'generateNull' and/or 'two.class.test' not found after sourcing the script.")
  }


  # --- 2. Prepare the observed counts matrix ---
  message("Preparing observed counts matrix...")
  # Set Idents (consistent with original code, though maybe not strictly needed for count calculation)
  Idents(seurat_obj) <- seurat_obj[[group_by_metadata, drop = TRUE]]

  ## Extract metadata
  md <- as.data.table(seurat_obj@meta.data)

  ## Count cells per unique combination of "orig.ident" and the grouping metadata
  counts_long <- md[, .N, by = c("orig.ident", group_by_metadata)]

  ## Create wide format matrix: orig.ident as rows, group_by_metadata as columns
  formula_dcast <- as.formula(paste("orig.ident ~", group_by_metadata))
  obs.counts.df <- dcast(counts_long, formula_dcast, value.var = "N", fill = 0) # Use fill=0 for NAs

  # Convert to matrix with orig.ident as rownames
  obs.counts <- obs.counts.df %>%
    tibble::remove_rownames() %>%
    tibble::column_to_rownames(var = "orig.ident") %>%
    as.matrix()

  ## Save the counts matrix
  count_filename <- file.path(output_dir_table, paste0(output_prefix, "_observed_counts_matrix.csv"))
  message("Saving observed counts matrix to: ", count_filename)
  write.csv(obs.counts, file = count_filename, row.names = TRUE)


  # --- 3. Run Differential Proportion Analysis ---
  message("Running Differential Proportion Analysis for ", length(comparisons), " comparisons across ", length(error_probabilities), " error probabilities...")

  # Initialize a list to store results for each comparison
  results_list <- vector("list", length(comparisons))
  comparison_names <- sapply(comparisons, function(x) paste0(x[1], "_vs_", x[2]))
  names(results_list) <- comparison_names

  # Pre-allocate result tables within the list
  for (comp_name in comparison_names) {
      results_list[[comp_name]] <- matrix(NA,
                                          nrow = length(error_probabilities),
                                          ncol = ncol(obs.counts), # Assuming two.class.test returns p-values for each group
                                          dimnames = list(as.character(error_probabilities), colnames(obs.counts)))
  }


  ## Loop through each error probability
  for (i in seq_along(error_probabilities)) {
    err_prob <- error_probabilities[i]
    message("  Generating null distribution for p = ", err_prob, " (", i, "/", length(error_probabilities), ")")
    # Generate the null distribution once per error probability
    tip.exp <- generateNull(obs.counts, n = n_iterations, p = err_prob)

    ## Loop through each specified comparison
    for (j in seq_along(comparisons)) {
      comp <- comparisons[[j]]
      comp_name <- comparison_names[j]
      cond_treatment <- comp[1]
      cond_control <- comp[2]

      message("    Testing: ", cond_treatment, " vs ", cond_control)
      # Run the two-class test
      res.1 <- tryCatch({
           two.class.test(obs.counts, tip.exp,
                         cond.control = cond_control,
                         cond.treatment = cond_treatment,
                         to.plot = FALSE)
      }, error = function(e) {
          warning("Error during two.class.test for ", comp_name, " at p=", err_prob, ": ", e$message)
          # Return a vector of NAs matching expected output dimension
          rep(NA_real_, ncol(obs.counts))
      })

      # Check if the result has the expected length
      if(length(res.1) == ncol(obs.counts)) {
          # Store the results in the pre-allocated matrix
          results_list[[comp_name]][as.character(err_prob), ] <- res.1
      } else {
          warning("Unexpected result length from two.class.test for ", comp_name, " at p=", err_prob, ". Expected ", ncol(obs.counts), " values, got ", length(res.1), ". Storing NAs.")
           results_list[[comp_name]][as.character(err_prob), ] <- rep(NA_real_, ncol(obs.counts))
      }
    } # End loop comparisons
  } # End loop error_probabilities


  # --- 4. Save Results Tables ---
  message("Saving results tables...")
  for (comp_name in names(results_list)) {
    result_filename <- file.path(output_dir_table, paste0(output_prefix, "_DPA_results_", comp_name, ".csv"))
    message("  Saving: ", result_filename)
    # write.csv expects a data frame usually, ensure matrix is handled correctly
    write.csv(results_list[[comp_name]], file = result_filename, row.names = TRUE)
  }

  message("Differential proportion analysis finished successfully!")

  # Return the list of results tables
  invisible(results_list)
}
```


```{r, plot for PF }
my_celltype_order <- c("Peri","Chondro","EC","LIG","PO","OG0","OG1","OG2","OG3","MG1", "MG2", "MG3", "MG4") # Define your order
calculate_and_plot_proportions(
   seurat_obj = suture_mes_mito_MAGIC_PF,
   group_by_metadata = "celltype",
   output_prefix = "suture_mes_mito_MAGIC_PF_harmony_celltype_ordered",
   output_dir_table = "./OutputTable",  # Custom table output directory
   output_dir_figure = "./OutputFigure", # Custom figure output directory
   relevel_vector = my_celltype_order       # Pass in ordering vector
 )
```

### 3.1.2 DPA approach

```{r, source functions for DPA assay}
source("diffprop_functions.R")
```

```{r,define comparison}
my_comparisons <- list(
  c("DM_PF", "WT_PF"),
  c("KO_PF", "WT_PF"),
  c("Runx2_PF", "WT_PF"),
  c("DM_PF", "Runx2_PF"),
  c("KO_PF", "Runx2_PF"),
  c("DM_PF", "KO_PF")
)
```

```{r}
# Compare Seurat object is suture_mes_mito_MAGIC_PF
dpa_results <- run_differential_proportion_analysis(
  seurat_obj = suture_mes_mito_MAGIC_PF,
  group_by_metadata = "celltype",  # Or other metadata like "seurat_clusters"
  comparisons = my_comparisons,
  output_prefix = "suture_mes_mito_MAGIC_PF_celltype_DPA_0430",
    output_dir_table = "./OutputTable"
)
```

### 3.1.3 Plot OG3
```{r}
# --- 1. Load the data ---
# Make sure the path to your file is correct
file_path <- "./OutputTable/suture_mes_mito_MAGIC_PF_harmony_celltype_ordered_cell_percentage_celltype.csv"

# Check if file exists before trying to read
if (!file.exists(file_path)) {
  stop("CSV file not found at: ", file_path)
}

percentage_data <- fread(file_path)

# Check the column names to be sure
print(colnames(percentage_data))
# Expected columns: "orig.ident", "celltype", "Percentage" (or similar)
# Adjust the code below if your column names are different.

# --- 2. Filter for OG3 celltype ---
# Using data.table syntax
og3_percentage_data <- percentage_data[celltype == "OG3"]



# --- 3. Create the bar chart for OG3 percentages ---
# Define output directory and prefix if needed for saving
output_dir_figure = "./OutputFigure" # Or your preferred directory
output_prefix = "suture_mes_mito_MAGIC_PF_harmony_OG3_only"

if (!dir.exists(output_dir_figure)) {
  dir.create(output_dir_figure, recursive = TRUE)
}


# Create the plot
# Using geom_col is appropriate here as 'Percentage' is the value to plot directly
p_og3_barplot <- ggplot(og3_percentage_data, aes(x = orig.ident, y = Percentage, fill = orig.ident)) +
  geom_col(color = "black", position = position_dodge()) + # Use dodge if you potentially had multiple bars per x category, though not strictly needed here. geom_col() without dodge is fine too.
  # geom_col(color = "black") + # Simpler version if dodging isn't needed
  ggtitle("Percentage of OG3 Cells within each Genotype") + # Title clarifying the meaning
  xlab("Genotype (orig.ident)") +
  ylab("Percentage (%)") + # Y-axis label
  scale_fill_discrete(name = "Genotype") + # Optional: Rename legend title
  coord_cartesian(ylim = c(0, 10)) +
  theme_bw(base_size = 12) +
  theme(
    panel.grid.major = element_blank(), # Cleaner background
    panel.grid.minor = element_blank(),
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1), # Rotate x-axis labels if needed
    legend.position = "right" # Or "bottom", "none" if fill is redundant
  )

# Print the plot to the screen
print(p_og3_barplot)

# --- 4. Save the plot (optional) ---
plot_filename <- file.path(output_dir_figure, paste0(output_prefix, "_percentage_barplot.pdf"))
message("Saving OG3 percentage barplot to: ", plot_filename)
ggsave(plot_filename, plot = p_og3_barplot, height = 5, width = 6) # Adjust size as needed
```













### 3.1.4 highlight OG
highlight cluster of interest: OG3
First, we will order the color code for each celltype, then use Dimplot to color OG3
```{r,fig.width=3, fig.height=3}
levels(suture_mes_mito_MAGIC_PF$celltype)
colors <- c("grey","grey","grey","grey","grey",
            "grey","grey","grey","#00B6EB","grey","grey",
            "grey","grey","grey")
DimPlot(suture_mes_mito_MAGIC_PF, label = T, cols = colors,repel = T)
ggsave("./OutputFigure/suture_mes_mito_MAGIC_PF_OG3_highlighted_0430.pdf", device = "pdf", width = 4, height = 3)
DimPlot(suture_mes_mito_MAGIC_PF, label = F, cols = colors,repel = T)+
  NoLegend()
ggsave("./OutputFigure/suture_mes_mito_MAGIC_PF_OG3_highlighted_nolabel_0430.pdf", device = "pdf", width = 3, height = 3)
```
```{r,fig.width=12, fig.height=3}
DimPlot(suture_mes_mito_MAGIC_PF, label = F, cols = colors,repel = T, split.by = "orig.ident")+
  NoLegend()
ggsave("./OutputFigure/suture_mes_mito_MAGIC_PF_OG3_highlighted_split_nolabel_0430.png", device = "png", width = 10, height = 3)
```
For OG2
highlight cluster of interest: OG2
First, we will order the color code for each celltype, then use Dimplot to color OG2
```{r,fig.width=3, fig.height=3}
levels(suture_mes_mito_MAGIC_PF$celltype)
colors <- c("grey","grey","grey","grey","grey",
            "grey","grey","#00BFC4","grey","grey","grey",
            "grey","grey","grey")
DimPlot(suture_mes_mito_MAGIC_PF, label = T, cols = colors,repel = T)+
  NoLegend()
ggsave("./OutputFigure/suture_mes_mito_MAGIC_PF_OG2_highlighted_0430.pdf", device = "pdf", width = 4, height = 3)
DimPlot(suture_mes_mito_MAGIC_PF, label = F, cols = colors,repel = T)+
  NoLegend()
ggsave("./OutputFigure/suture_mes_mito_MAGIC_PF_OG2_highlighted_nolabel_0430.pdf", device = "pdf", width = 3, height = 3)
```
```{r,fig.width=12, fig.height=3}
DimPlot(suture_mes_mito_MAGIC_PF, label = F, cols = colors,repel = T, split.by = "orig.ident")+
  NoLegend()
ggsave("./OutputFigure/suture_mes_mito_MAGIC_PF_OG2_highlighted_split_nolabel_0430.png", device = "png", width = 10, height = 3)
```

highlight cluster of interest: OG1
First, we will order the color code for each celltype, then use Dimplot to color OG1
```{r,fig.width=3, fig.height=3}
levels(suture_mes_mito_MAGIC_PF$celltype)
colors <- c("grey","grey","grey","grey","grey","grey",
            "#00C094","grey","grey","grey","grey",
            "grey","grey","grey")
DimPlot(suture_mes_mito_MAGIC_PF, label = T, cols = colors,repel = T)+
  NoLegend()
ggsave("./OutputFigure/suture_mes_mito_MAGIC_PF_OG1_highlighted_0430.pdf", device = "pdf", width = 4, height = 3)
DimPlot(suture_mes_mito_MAGIC_PF, label = F, cols = colors,repel = T)+
  NoLegend()
ggsave("./OutputFigure/suture_mes_mito_MAGIC_PF_OG1_highlighted_nolabel_0430.pdf", device = "pdf", width = 3, height = 3)
```
```{r,fig.width=12, fig.height=3}
DimPlot(suture_mes_mito_MAGIC_PF, label = F, cols = colors,repel = T, split.by = "orig.ident")+
  NoLegend()
ggsave("./OutputFigure/suture_mes_mito_MAGIC_PF_OG1_highlighted_split_nolabel_0430.png", device = "png", width = 10, height = 3)
```

```{r,fig.width=3, fig.height=3}
levels(suture_mes_mito_MAGIC_PF$celltype)
colors <- c("grey","grey","grey","grey","grey","#00BC56",
            "grey","grey","grey","grey","grey",
            "grey","grey","grey")
DimPlot(suture_mes_mito_MAGIC_PF, label = T, cols = colors,repel = T)+
  NoLegend()
ggsave("./OutputFigure/suture_mes_mito_MAGIC_PF_OG0_highlighted_0430.pdf", device = "pdf", width = 4, height = 3)
DimPlot(suture_mes_mito_MAGIC_PF, label = F, cols = colors,repel = T)+
  NoLegend()
ggsave("./OutputFigure/suture_mes_mito_MAGIC_PF_OG0_highlighted_nolabel_0430.pdf", device = "pdf", width = 3, height = 3)
```

```{r,fig.width=12, fig.height=3}
DimPlot(suture_mes_mito_MAGIC_PF, label = F, cols = colors,repel = T, split.by = "orig.ident")+
  NoLegend()
ggsave("./OutputFigure/suture_mes_mito_MAGIC_PF_OG0_highlighted_split_nolabel_0430.png", device = "png", width = 10, height = 3)
```

##3.2 SAG
### 3.2.1 Load data
```{r,load data}
gc()
rm(list=ls())
suture_mes_mito_MAGIC_SAG <- readRDS(file = "./SeuratObject/suture_mes_mito_MAGIC_harmony_renamed_SAG_0430.rds")
```

```{r, change levels}
suture_mes_mito_MAGIC_SAG$celltype <- factor(suture_mes_mito_MAGIC_SAG$celltype, levels = c("Peri","Chondro","EC","LIG","PO","OG0","OG1","OG2","OG3","MG1", "MG2", "MG3", "MG4","MG5","removed")) 
levels(suture_mes_mito_MAGIC_SAG$celltype)
```

```{r,check umap plot}
DimPlot(suture_mes_mito_MAGIC_SAG, reduction = "umap", label = T)
DimPlot(suture_mes_mito_MAGIC_SAG, reduction = "umap", group.by = "celltype")
```


```{r,prepare function for cell percentage}
# --- Ensure necessary libraries are loaded ---
# install.packages(c("Seurat", "ggplot2", "data.table", "dplyr", "forcats", "reshape2")) # If needed, uncomment and run to install
library(Seurat)
library(ggplot2)
library(data.table)
library(dplyr)
library(forcats)
library(reshape2) # melt function is in this package (although data.table::melt also works)

#' @title Calculate and Plot Cell Proportions from Seurat Object Metadata
#'
#' @description This function takes a Seurat object, extracts metadata, calculates cell counts
#'              and percentages grouped by 'orig.ident' and a specified metadata column,
#'              saves the results to CSV files, and generates several summary plots.
#'
#' @param seurat_obj A Seurat object.
#' @param group_by_metadata A string specifying the metadata column name to group cells by (e.g., "celltype", "seurat_clusters").
#' @param output_prefix A string used as a prefix for all output file names. Helps in organizing outputs.
#' @param output_dir_table Path to the directory where CSV tables will be saved. Defaults to "./OutputTable".
#' @param output_dir_figure Path to the directory where PDF plots will be saved. Defaults to "./OutputFigure".
#' @param relevel_vector An optional character vector specifying the desired order of levels for the `group_by_metadata` factor on the plot's x-axis. If NULL (default), the default factor ordering is used.
#'
#' @return Invisibly returns the long-format data table containing percentages (`split_count_mut_melt`).
#'
#' @importFrom Seurat Idents<-
#' @import data.table
#' @import dplyr
#' @import ggplot2
#' @import forcats
#' @import reshape2
#'
#' @examples
#' \dontrun{
#' # Assume you have a Seurat object named 'my_seurat_object'
#' # and you want to group by 'celltype' metadata
#' calculate_and_plot_proportions(
#'   seurat_obj = my_seurat_object,
#'   group_by_metadata = "celltype",
#'   output_prefix = "my_analysis_celltype",
#'   relevel_vector = c("TypeA", "TypeC", "TypeB") # Optional ordering
#' )
#'
#' # Group by 'seurat_clusters'
#' calculate_and_plot_proportions(
#'   seurat_obj = my_seurat_object,
#'   group_by_metadata = "seurat_clusters",
#'   output_prefix = "my_analysis_clusters"
#' )
#' }

calculate_and_plot_proportions <- function(seurat_obj,
                                           group_by_metadata,
                                           output_prefix,
                                           output_dir_table = "./OutputTable",
                                           output_dir_figure = "./OutputFigure",
                                           relevel_vector = NULL) {

  # --- Parameter validation ---
  if (!inherits(seurat_obj, "Seurat")) {
    stop("Input 'seurat_obj' must be a Seurat object.")
  }
  if (!is.character(group_by_metadata) || length(group_by_metadata) != 1) {
    stop("'group_by_metadata' must be a single string.")
  }
  if (!group_by_metadata %in% colnames(seurat_obj@meta.data)) {
    stop(paste("Metadata column", shQuote(group_by_metadata), "not found in the Seurat object."))
  }
  if (!is.character(output_prefix) || length(output_prefix) != 1) {
    stop("'output_prefix' must be a single string.")
  }
  if (!dir.exists(output_dir_table)) {
      message("Creating output table directory: ", output_dir_table)
      dir.create(output_dir_table, recursive = TRUE)
  }
   if (!dir.exists(output_dir_figure)) {
      message("Creating output figure directory: ", output_dir_figure)
      dir.create(output_dir_figure, recursive = TRUE)
  }


  # --- 1. Extract and calculate cell counts ---
  message("Step 1: Calculating cell counts...")
  # Set Idents (although not directly used for counting in this specific workflow, but consistent with original code)
  Idents(seurat_obj) <- seurat_obj[[group_by_metadata, drop = TRUE]]

  ## Extract metadata
  md <- as.data.table(seurat_obj@meta.data)

  ## Calculate cell counts by "orig.ident" and specified metadata column
  split_count_long <- md[, .N, by = c("orig.ident", group_by_metadata)]
  setnames(split_count_long, "N", "Number") # Rename count column

  ## Convert to wide format (dcast)
  # Build dcast formula
  formula_dcast <- as.formula(paste("orig.ident ~", group_by_metadata))
  split_count_wide <- dcast(split_count_long, formula_dcast, value.var = "Number", fill = 0) # fill=0 replaces NA

  ## Convert back to long format (melt) - for plotting and saving
  split_count_melt <- melt(split_count_wide,
                           id.vars = "orig.ident",
                           variable.name = group_by_metadata, # Use input parameter
                           value.name = "Number")
  # Ensure the group_by_metadata column after melt is factor type
  split_count_melt[[group_by_metadata]] <- as.factor(split_count_melt[[group_by_metadata]])


  ## Save original counts (long format)
  count_filename_csv <- file.path(output_dir_table, paste0(output_prefix, "_cell_number_", group_by_metadata, ".csv"))
  message("Saving raw counts (long format) to: ", count_filename_csv)
  fwrite(split_count_melt, file = count_filename_csv, row.names = FALSE)

  # --- 2. Plot proportional chart of original counts ---
  message("Step 2: Generating count proportion plot...")

  # Factor level reordering (if provided)
  if (!is.null(relevel_vector)) {
    message("Releveling factor: ", group_by_metadata)
    # Check if all provided levels are in the data
    current_levels <- levels(split_count_melt[[group_by_metadata]])
    if (!all(relevel_vector %in% current_levels)) {
        warning("Some levels in 'relevel_vector' are not present in the data for column '", group_by_metadata, "'. Proceeding with available levels.")
        relevel_vector <- intersect(relevel_vector, current_levels)
    }
     if (length(relevel_vector) > 0) {
       split_count_melt[[group_by_metadata]] <- fct_relevel(split_count_melt[[group_by_metadata]], relevel_vector)
     } else {
        warning("No valid levels remaining in 'relevel_vector' after checking against data. Skipping releveling.")
     }
  }

  p1 <- ggplot(split_count_melt, aes(fill = orig.ident, x = .data[[group_by_metadata]], y = Number)) +
    geom_bar(position = "fill", stat = "identity") +
    ggtitle(paste("Proportion of cells per", group_by_metadata, "across identities (raw counts)")) +
    xlab(group_by_metadata) +
    ylab("Proportion of cells") +
    theme_minimal(base_size = 12) + # Use a slightly cleaner theme
    theme(
        plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1), # Rotate X-axis labels to prevent overlap
        legend.position = "bottom" # Place legend at bottom
        )

  plot_filename_p1 <- file.path(output_dir_figure, paste0(output_prefix, "_Percentage_cell_in_each_", group_by_metadata, "_unnormalized.pdf"))
  message("Saving count proportion plot to: ", plot_filename_p1)
  ggsave(plot_filename_p1, plot = p1, height = 5, width = max(7.5, length(levels(split_count_melt[[group_by_metadata]]))*0.5 + 2 )) # Dynamic width

  # --- 3. Calculate percentages within each orig.ident ---
  message("Step 3: Calculating percentages within each orig.ident...")

  # Use data.table chaining operations to calculate percentages more efficiently
  # Start from long format counts
  split_count_long[, total_per_ident := sum(Number), by = orig.ident] # Calculate total for each orig.ident
  split_count_long[, Percentage := fifelse(total_per_ident > 0, (Number / total_per_ident) * 100, 0), by = orig.ident] # Calculate percentage, handle cases where total is 0

  # Extract long format percentage data for saving and plotting
  split_count_mut_melt <- split_count_long[, .(orig.ident, get(group_by_metadata), Percentage)]
  setnames(split_count_mut_melt, "V2", group_by_metadata) # Rename column name generated by get()
  # Ensure factor type and order are consistent with previous
  split_count_mut_melt[[group_by_metadata]] <- factor(split_count_mut_melt[[group_by_metadata]], levels = levels(split_count_melt[[group_by_metadata]]))


  # Create wide format percentage data for saving
  formula_dcast_perc <- as.formula(paste("orig.ident ~", group_by_metadata))
  split_count_mut_wide <- dcast(split_count_mut_melt, formula_dcast_perc, value.var = "Percentage", fill = 0)

  ## Save wide format percentage table
  perc_wide_filename_csv <- file.path(output_dir_table, paste0(output_prefix, "_cell_percentage_", group_by_metadata, "_unmelt.csv"))
  message("Saving percentages (wide format) to: ", perc_wide_filename_csv)
  fwrite(split_count_mut_wide, file = perc_wide_filename_csv, row.names = FALSE)

  ## Save long format percentage table
  perc_long_filename_csv <- file.path(output_dir_table, paste0(output_prefix, "_cell_percentage_", group_by_metadata, ".csv"))
  message("Saving percentages (long format) to: ", perc_long_filename_csv)
  fwrite(split_count_mut_melt, file = perc_long_filename_csv, row.names = FALSE)

  # --- 4. Plot percentage charts ---
  message("Step 4: Generating percentage plots...")

  ## 4a. Percentage stacked bar chart (filled by group, showing proportions) - Note this will look the same as p1 visually
  p2 <- ggplot(split_count_mut_melt, aes(fill = orig.ident, x = .data[[group_by_metadata]], y = Percentage)) +
    geom_bar(position = "fill", stat = "identity") + # position="fill" will recalculate proportions
    ggtitle(paste("Proportion of cells per", group_by_metadata, "across identities (normalized proportions)")) +
    xlab(group_by_metadata) +
    ylab("Proportion of cells") +
    theme_minimal(base_size = 12) +
    theme(
        plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        legend.position = "bottom"
        )

  plot_filename_p2 <- file.path(output_dir_figure, paste0(output_prefix, "_Percentage_cell_in_each_", group_by_metadata, "_normalized_fill.pdf"))
  message("Saving percentage proportion plot (fill) to: ", plot_filename_p2)
  ggsave(plot_filename_p2, plot = p2, height = 5, width = max(7.5, length(levels(split_count_mut_melt[[group_by_metadata]]))*0.5 + 2 ))

  ## 4b. Percentage stacked bar chart (directly showing calculated percentages)
  # Using geom_col equivalent to geom_bar(stat="identity")
  p3 <- ggplot(split_count_mut_melt, aes(x = .data[[group_by_metadata]], y = Percentage, fill = orig.ident)) +
    geom_col(color = "black") + # Add black borders
    ggtitle(paste("Percentage of cells within each", group_by_metadata)) +
    xlab(group_by_metadata) +
    ylab("Percentage (%)") +
    theme_bw(base_size = 12) +
    theme(
        panel.grid = element_blank(), # Remove background grid lines
        plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        legend.position = "bottom"
        )

  plot_filename_p3 <- file.path(output_dir_figure, paste0(output_prefix, "_Percentage_cell_in_each_", group_by_metadata, "_normalized_stack.pdf"))
  message("Saving percentage stacked plot to: ", plot_filename_p3)
  ggsave(plot_filename_p3, plot = p3, height = 5, width = max(7.5, length(levels(split_count_mut_melt[[group_by_metadata]]))*0.5 + 2 ))


  ## 4c. Percentage side-by-side bar chart (Dodge)
  p4 <- ggplot(split_count_mut_melt, aes(x = .data[[group_by_metadata]], y = Percentage, fill = orig.ident)) +
    geom_col(color = "black", position = position_dodge(preserve = "single")) + # Use position_dodge and preserve single bar positions
    ggtitle(paste("Percentage of cells within each", group_by_metadata)) +
    xlab(group_by_metadata) +
    ylab("Percentage (%)") +
    theme_bw(base_size = 12) +
    theme(
        panel.grid = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        legend.position = "bottom"
        )

  plot_filename_p4 <- file.path(output_dir_figure, paste0(output_prefix, "_Percentage_cell_in_each_", group_by_metadata, "_normalized_dodge.pdf"))
  message("Saving percentage dodged plot to: ", plot_filename_p4)
  # Dodge plots usually need wider space
  ggsave(plot_filename_p4, plot = p4, height = 5, width = max(8, length(levels(split_count_mut_melt[[group_by_metadata]])) * length(unique(split_count_mut_melt$orig.ident)) * 0.2 + 3))

  message("Function finished successfully!")

  # Return long format percentage data frame for continued use in R environment
  invisible(split_count_mut_melt)
}

# --- How to use ---
# Assume your Seurat object is called suture_mes_mito_MAGIC_PF
# and you want to group by "celltype"

# Example usage 1: Basic usage
# calculate_and_plot_proportions(
#   seurat_obj = suture_mes_mito_MAGIC_PF,
#   group_by_metadata = "celltype",
#   output_prefix = "suture_mes_mito_MAGIC_PF_harmony_celltype" # Provide a filename prefix
# )

# Example usage 2: Specify output directories and factor ordering
# my_celltype_order <- c("Peri","Chondro","EC","LIG","PO","OG1","OG2","OG3","MG1", "MG2", "MG3", "MG4") # Define your order
# calculate_and_plot_proportions(
#   seurat_obj = suture_mes_mito_MAGIC_PF,
#   group_by_metadata = "celltype",
#   output_prefix = "suture_mes_mito_MAGIC_PF_harmony_celltype_ordered",
#   output_dir_table = "./CustomTables",  # Custom table output directory
#   output_dir_figure = "./CustomFigures", # Custom figure output directory
#   relevel_vector = my_celltype_order       # Pass in ordering vector
# )

# Example usage 3: Group by different metadata, such as 'seurat_clusters'
# calculate_and_plot_proportions(
#   seurat_obj = suture_mes_mito_MAGIC_PF,
#   group_by_metadata = "seurat_clusters",
#   output_prefix = "suture_mes_mito_MAGIC_PF_harmony_clusters"
# )
```

```{r,DPA-based percentage comparison}
# --- Ensure necessary libraries are loaded ---
# install.packages(c("Seurat", "data.table", "dplyr", "tibble")) # If needed
library(Seurat)
library(data.table)
library(dplyr)
library(tibble) # For remove_rownames and column_to_rownames

#' @title Perform Differential Cell Proportion Analysis
#'
#' @description This function automates the process of calculating cell counts per group
#'              and condition, performing pairwise differential proportion tests using
#'              functions from an external script (e.g., diffprop_functions.R), and
#'              saving the results across a range of error probabilities.
#'
#' @param seurat_obj A Seurat object.
#' @param group_by_metadata A string specifying the metadata column name to group cells by (e.g., "celltype"). This column defines the populations whose proportions are compared.
#' @param comparisons A list of character vectors. Each vector must have length 2,
#'                   in the format `c("condition_treatment", "condition_control")`.
#'                   These values must correspond to unique values in the 'orig.ident'
#'                   column of the Seurat object's metadata.
#'                   Example: `list(c("DM_PF", "WT_PF"), c("KO_PF", "WT_PF"))`.
#' @param error_probabilities A numeric vector of error probabilities (p) to test in `generateNull`.
#'                            Defaults to `c(0.5, 0.4, 0.3, 0.25, 0.2, 0.15, 0.1, 0.05)`.
#' @param n_iterations An integer specifying the number of iterations ('n') for `generateNull`.
#'                     Defaults to 100000.
#' @param diffprop_script_path The file path to the R script containing the `generateNull`
#'                             and `two.class.test` functions. Defaults to "diffprop_functions.R".
#' @param output_prefix A string used as a prefix for all output file names.
#' @param output_dir_table Path to the directory where CSV tables will be saved. Defaults to "./OutputTable".
#'
#' @return A list containing the results tables (p-values) for each comparison across the specified error probabilities. Each element in the list corresponds to a comparison.
#'
#' @importFrom Seurat Idents<-
#' @import data.table
#' @import dplyr
#' @import tibble
#'
#' @export
#'
#' @examples
#' \dontrun{
#' # Assume 'suture_mes_mito_MAGIC_PF' is your Seurat object
#' # Assume 'diffprop_functions.R' is in your working directory or accessible path
#'
#' # Define the comparisons you want to make
#' my_comparisons <- list(
#'   c("DM_PF", "WT_PF"),
#'   c("KO_PF", "WT_PF"),
#'   c("Runx2_PF", "WT_PF"),
#'   c("DM_PF", "Runx2_PF"),
#'   c("KO_PF", "Runx2_PF"),
#'   c("DM_PF", "KO_PF")
#' )
#'
#' # Run the analysis
#' results_list <- run_differential_proportion_analysis(
#'   seurat_obj = suture_mes_mito_MAGIC_PF,
#'   group_by_metadata = "celltype",
#'   comparisons = my_comparisons,
#'   output_prefix = "suture_mes_mito_MAGIC_PF_DPA"
#' )
#'
#' # Access results for a specific comparison, e.g., DM_PF vs WT_PF
#' # dm_vs_wt_results <- results_list[["DM_PF_vs_WT_PF"]]
#' # print(dm_vs_wt_results)
#' }
run_differential_proportion_analysis <- function(
    seurat_obj,
    group_by_metadata,
    comparisons,
    error_probabilities = c(0.5, 0.4, 0.3, 0.25, 0.2, 0.15, 0.1, 0.05),
    n_iterations = 100000,
    diffprop_script_path = "diffprop_functions.R",
    output_prefix,
    output_dir_table = "./OutputTable"
) {

  # --- Input Validation ---
  if (!inherits(seurat_obj, "Seurat")) {
    stop("Input 'seurat_obj' must be a Seurat object.")
  }
  if (!is.character(group_by_metadata) || length(group_by_metadata) != 1) {
    stop("'group_by_metadata' must be a single string.")
  }
  if (!group_by_metadata %in% colnames(seurat_obj@meta.data)) {
    stop("Metadata column ", shQuote(group_by_metadata), " not found in the Seurat object.")
  }
  if (!is.list(comparisons) || length(comparisons) == 0) {
      stop("'comparisons' must be a non-empty list.")
  }
  if (!all(sapply(comparisons, function(x) is.character(x) && length(x) == 2))) {
      stop("Each element in 'comparisons' must be a character vector of length 2: c('treatment', 'control').")
  }
  all_conditions <- unique(unlist(comparisons))
  if (!all(all_conditions %in% unique(seurat_obj$orig.ident))) {
      missing_cond <- setdiff(all_conditions, unique(seurat_obj$orig.ident))
      stop("The following conditions specified in 'comparisons' are not found in seurat_obj$orig.ident: ",
           paste(missing_cond, collapse=", "))
  }
  if (!file.exists(diffprop_script_path)) {
    stop("Differential proportion functions script not found at: ", diffprop_script_path)
  }
   if (!dir.exists(output_dir_table)) {
      message("Creating output table directory: ", output_dir_table)
      dir.create(output_dir_table, recursive = TRUE)
  }
  if (!is.character(output_prefix) || length(output_prefix) != 1) {
    stop("'output_prefix' must be a single string.")
  }


  # --- 1. Source the differential proportion functions ---
  message("Sourcing functions from: ", diffprop_script_path)
  source(diffprop_script_path)
  # Check if functions are loaded (optional but good practice)
  if (!exists("generateNull") || !exists("two.class.test")) {
      stop("Functions 'generateNull' and/or 'two.class.test' not found after sourcing the script.")
  }


  # --- 2. Prepare the observed counts matrix ---
  message("Preparing observed counts matrix...")
  # Set Idents (consistent with original code, though maybe not strictly needed for count calculation)
  Idents(seurat_obj) <- seurat_obj[[group_by_metadata, drop = TRUE]]

  ## Extract metadata
  md <- as.data.table(seurat_obj@meta.data)

  ## Count cells per unique combination of "orig.ident" and the grouping metadata
  counts_long <- md[, .N, by = c("orig.ident", group_by_metadata)]

  ## Create wide format matrix: orig.ident as rows, group_by_metadata as columns
  formula_dcast <- as.formula(paste("orig.ident ~", group_by_metadata))
  obs.counts.df <- dcast(counts_long, formula_dcast, value.var = "N", fill = 0) # Use fill=0 for NAs

  # Convert to matrix with orig.ident as rownames
  obs.counts <- obs.counts.df %>%
    tibble::remove_rownames() %>%
    tibble::column_to_rownames(var = "orig.ident") %>%
    as.matrix()

  ## Save the counts matrix
  count_filename <- file.path(output_dir_table, paste0(output_prefix, "_observed_counts_matrix.csv"))
  message("Saving observed counts matrix to: ", count_filename)
  write.csv(obs.counts, file = count_filename, row.names = TRUE)


  # --- 3. Run Differential Proportion Analysis ---
  message("Running Differential Proportion Analysis for ", length(comparisons), " comparisons across ", length(error_probabilities), " error probabilities...")

  # Initialize a list to store results for each comparison
  results_list <- vector("list", length(comparisons))
  comparison_names <- sapply(comparisons, function(x) paste0(x[1], "_vs_", x[2]))
  names(results_list) <- comparison_names

  # Pre-allocate result tables within the list
  for (comp_name in comparison_names) {
      results_list[[comp_name]] <- matrix(NA,
                                          nrow = length(error_probabilities),
                                          ncol = ncol(obs.counts), # Assuming two.class.test returns p-values for each group
                                          dimnames = list(as.character(error_probabilities), colnames(obs.counts)))
  }


  ## Loop through each error probability
  for (i in seq_along(error_probabilities)) {
    err_prob <- error_probabilities[i]
    message("  Generating null distribution for p = ", err_prob, " (", i, "/", length(error_probabilities), ")")
    # Generate the null distribution once per error probability
    tip.exp <- generateNull(obs.counts, n = n_iterations, p = err_prob)

    ## Loop through each specified comparison
    for (j in seq_along(comparisons)) {
      comp <- comparisons[[j]]
      comp_name <- comparison_names[j]
      cond_treatment <- comp[1]
      cond_control <- comp[2]

      message("    Testing: ", cond_treatment, " vs ", cond_control)
      # Run the two-class test
      res.1 <- tryCatch({
           two.class.test(obs.counts, tip.exp,
                         cond.control = cond_control,
                         cond.treatment = cond_treatment,
                         to.plot = FALSE)
      }, error = function(e) {
          warning("Error during two.class.test for ", comp_name, " at p=", err_prob, ": ", e$message)
          # Return a vector of NAs matching expected output dimension
          rep(NA_real_, ncol(obs.counts))
      })

      # Check if the result has the expected length
      if(length(res.1) == ncol(obs.counts)) {
          # Store the results in the pre-allocated matrix
          results_list[[comp_name]][as.character(err_prob), ] <- res.1
      } else {
          warning("Unexpected result length from two.class.test for ", comp_name, " at p=", err_prob, ". Expected ", ncol(obs.counts), " values, got ", length(res.1), ". Storing NAs.")
           results_list[[comp_name]][as.character(err_prob), ] <- rep(NA_real_, ncol(obs.counts))
      }
    } # End loop comparisons
  } # End loop error_probabilities


  # --- 4. Save Results Tables ---
  message("Saving results tables...")
  for (comp_name in names(results_list)) {
    result_filename <- file.path(output_dir_table, paste0(output_prefix, "_DPA_results_", comp_name, ".csv"))
    message("  Saving: ", result_filename)
    # write.csv expects a data frame usually, ensure matrix is handled correctly
    write.csv(results_list[[comp_name]], file = result_filename, row.names = TRUE)
  }

  message("Differential proportion analysis finished successfully!")

  # Return the list of results tables
  invisible(results_list)
}
```


```{r, plot for SAG }
my_celltype_order <- c("Peri","Chondro","EC","LIG","PO","OG0","OG1","OG2","OG3","MG1", "MG2", "MG3", "MG4") # Define your order
calculate_and_plot_proportions(
   seurat_obj = suture_mes_mito_MAGIC_SAG,
   group_by_metadata = "celltype",
   output_prefix = "suture_mes_mito_MAGIC_SAG_harmony_celltype_ordered",
   output_dir_table = "./OutputTable",  # Custom table output directory
   output_dir_figure = "./OutputFigure", # Custom figure output directory
   relevel_vector = my_celltype_order       # Pass in ordering vector
 )
```

### 3.2.2 DPA approach

```{r, source functions for DPA assay}
source("diffprop_functions.R")
```

```{r,define comparison}
my_comparisons <- list(
  c("DM_SAG", "WT_SAG"),
  c("KO_SAG", "WT_SAG"),
  c("Runx2_SAG", "WT_SAG"),
  c("DM_SAG", "Runx2_SAG"),
  c("KO_SAG", "Runx2_SAG"),
  c("DM_SAG", "KO_SAG")
)
```

```{r}
# Compare Seurat object is suture_mes_mito_MAGIC_SAG
dpa_results <- run_differential_proportion_analysis(
  seurat_obj = suture_mes_mito_MAGIC_SAG,
  group_by_metadata = "celltype",  # Or other metadata like "seurat_clusters"
  comparisons = my_comparisons,
  output_prefix = "suture_mes_mito_MAGIC_SAG_celltype_DPA_0430",
    output_dir_table = "./OutputTable"
)
```

### 3.2.3 Plot OG3
```{r}

# --- 1. Load the data ---
# Make sure the path to your file is correct
file_path <- "./OutputTable/suture_mes_mito_MAGIC_SAG_harmony_celltype_ordered_cell_percentage_celltype.csv"

# Check if file exists before trying to read
if (!file.exists(file_path)) {
  stop("CSV file not found at: ", file_path)
}

percentage_data <- fread(file_path)

# Check the column names to be sure
print(colnames(percentage_data))
# Expected columns: "orig.ident", "celltype", "Percentage" (or similar)
# Adjust the code below if your column names are different.

# --- 2. Filter for OG3 celltype ---
# Using data.table syntax
og3_percentage_data <- percentage_data[celltype == "OG3"]



# --- 3. Create the bar chart for OG3 percentages ---
# Define output directory and prefix if needed for saving
output_dir_figure = "./OutputFigure" # Or your preferred directory
output_prefix = "suture_mes_mito_MAGIC_SAG_harmony_OG3_only"

if (!dir.exists(output_dir_figure)) {
  dir.create(output_dir_figure, recursive = TRUE)
}


# Create the plot
# Using geom_col is appropriate here as 'Percentage' is the value to plot directly
p_og3_barplot <- ggplot(og3_percentage_data, aes(x = orig.ident, y = Percentage, fill = orig.ident)) +
  geom_col(color = "black", position = position_dodge()) + # Use dodge if you potentially had multiple bars per x category, though not strictly needed here. geom_col() without dodge is fine too.
  # geom_col(color = "black") + # Simpler version if dodging isn't needed
  ggtitle("Percentage of OG3 Cells within each Genotype") + # Title clarifying the meaning
  xlab("Genotype (orig.ident)") +
  ylab("Percentage (%)") + # Y-axis label
  scale_fill_discrete(name = "Genotype") + # Optional: Rename legend title
  coord_cartesian(ylim = c(0, 10)) +
  theme_bw(base_size = 12) +
  theme(
    panel.grid.major = element_blank(), # Cleaner background
    panel.grid.minor = element_blank(),
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1), # Rotate x-axis labels if needed
    legend.position = "right" # Or "bottom", "none" if fill is redundant
  )

# Print the plot to the screen
print(p_og3_barplot)

# --- 4. Save the plot (optional) ---
plot_filename <- file.path(output_dir_figure, paste0(output_prefix, "_percentage_barplot.pdf"))
message("Saving OG3 percentage barplot to: ", plot_filename)
ggsave(plot_filename, plot = p_og3_barplot, height = 5, width = 6) # Adjust size as needed
```



### 3.2.4 highlight OG
highlight cluster of interest: OG3
First, we will order the color code for each celltype, then use Dimplot to color OG3
```{r,fig.width=3, fig.height=3}
levels(suture_mes_mito_MAGIC_SAG$celltype)
colors <- c("grey","grey","grey","grey","grey",
            "grey","grey","grey","#00B6EB","grey","grey",
            "grey","grey","grey")
DimPlot(suture_mes_mito_MAGIC_SAG, label = T, cols = colors,repel = T)+
  NoLegend()
ggsave("./OutputFigure/suture_mes_mito_MAGIC_SAG_OG3_highlighted_0430.pdf", device = "pdf", width = 4, height = 3)
DimPlot(suture_mes_mito_MAGIC_SAG, label = F, cols = colors,repel = T)+
  NoLegend()
ggsave("./OutputFigure/suture_mes_mito_MAGIC_SAG_OG3_highlighted_nolabel_0430.pdf", device = "pdf", width = 3, height = 3)
```
```{r,fig.width=12, fig.height=3}
DimPlot(suture_mes_mito_MAGIC_SAG, label = F, cols = colors,repel = T, split.by = "orig.ident")+
  NoLegend()
ggsave("./OutputFigure/suture_mes_mito_MAGIC_SAG_OG3_highlighted_split_nolabel_0430.png", device = "png", width = 10, height = 3)
```
For OG2
highlight cluster of interest: OG2
First, we will order the color code for each celltype, then use Dimplot to color OG2
```{r,fig.width=3, fig.height=3}
levels(suture_mes_mito_MAGIC_SAG$celltype)
colors <- c("grey","grey","grey","grey","grey","grey",
            "grey","#00BFC4","grey","grey","grey",
            "grey","grey","grey")
DimPlot(suture_mes_mito_MAGIC_SAG, label = T, cols = colors,repel = T)+
  NoLegend()
ggsave("./OutputFigure/suture_mes_mito_MAGIC_SAG_OG2_highlighted_0430.pdf", device = "pdf", width = 4, height = 3)
DimPlot(suture_mes_mito_MAGIC_SAG, label = F, cols = colors,repel = T)+
  NoLegend()
ggsave("./OutputFigure/suture_mes_mito_MAGIC_SAG_OG2_highlighted_nolabel_0430.pdf", device = "pdf", width = 3, height = 3)
```
```{r,fig.width=12, fig.height=3}
DimPlot(suture_mes_mito_MAGIC_SAG, label = F, cols = colors,repel = T, split.by = "orig.ident")+
  NoLegend()
ggsave("./OutputFigure/suture_mes_mito_MAGIC_SAG_OG2_highlighted_split_nolabel_0430.png", device = "png", width = 10, height = 3)
```

highlight cluster of interest: OG1
First, we will order the color code for each celltype, then use Dimplot to color OG1
```{r,fig.width=3, fig.height=3}
levels(suture_mes_mito_MAGIC_SAG$celltype)
colors <- c("grey","grey","grey","grey","grey","grey",
            "#00C094","grey","grey","grey","grey",
            "grey","grey","grey")
DimPlot(suture_mes_mito_MAGIC_SAG, label = T, cols = colors,repel = T)+
  NoLegend()
ggsave("./OutputFigure/suture_mes_mito_MAGIC_SAG_OG1_highlighted_0430.pdf", device = "pdf", width = 4, height = 3)
DimPlot(suture_mes_mito_MAGIC_SAG, label = F, cols = colors,repel = T)+
  NoLegend()
ggsave("./OutputFigure/suture_mes_mito_MAGIC_SAG_OG1_highlighted_nolabel_0430.pdf", device = "pdf", width = 3, height = 3)
```
```{r,fig.width=12, fig.height=3}
DimPlot(suture_mes_mito_MAGIC_SAG, label = F, cols = colors,repel = T, split.by = "orig.ident")+
  NoLegend()
ggsave("./OutputFigure/suture_mes_mito_MAGIC_SAG_OG1_highlighted_split_nolabel_0430.png", device = "png", width = 10, height = 3)
```



```{r,fig.width=3, fig.height=3}
levels(suture_mes_mito_MAGIC_SAG$celltype)
colors <- c("grey","grey","grey","grey","grey","#00BC56",
            "grey","grey","grey","grey","grey",
            "grey","grey","grey")
DimPlot(suture_mes_mito_MAGIC_SAG, label = T, cols = colors,repel = T)+
  NoLegend()
ggsave("./OutputFigure/suture_mes_mito_MAGIC_SAG_OG0_highlighted_0430.pdf", device = "pdf", width = 4, height = 3)
DimPlot(suture_mes_mito_MAGIC_SAG, label = F, cols = colors,repel = T)+
  NoLegend()
ggsave("./OutputFigure/suture_mes_mito_MAGIC_SAG_OG0_highlighted_nolabel_0430.pdf", device = "pdf", width = 3, height = 3)
```
```{r,fig.width=12, fig.height=3}
DimPlot(suture_mes_mito_MAGIC_SAG, label = F, cols = colors,repel = T, split.by = "orig.ident")+
  NoLegend()
ggsave("./OutputFigure/suture_mes_mito_MAGIC_SAG_OG0_highlighted_split_nolabel_0430.png", device = "png", width = 10, height = 3)
```

# 4 Split OG object
## 4.1 Load data
```{r}
gc()
rm(list=ls())
suture_mes_mito_MAGIC <- readRDS(file = "./SeuratObject/suture_mes_mito_MAGIC_harmony_renamed_20250420.rds")

```

```{r, check the order of celltype for display}
levels(suture_mes_mito_MAGIC@meta.data$celltype)
```
## 4.2 Split by cluster/celltype
```{r}
suture_mes_mito_MAGIC_OG0 <- subset(suture_mes_mito_MAGIC, idents="OG0")
suture_mes_mito_MAGIC_OG1 <- subset(suture_mes_mito_MAGIC, idents="OG1")
suture_mes_mito_MAGIC_OG2 <- subset(suture_mes_mito_MAGIC, idents="OG2")
suture_mes_mito_MAGIC_OG3 <- subset(suture_mes_mito_MAGIC, idents="OG3")
suture_mes_mito_MAGIC_OG <- subset(suture_mes_mito_MAGIC, idents=c("OG0","OG1","OG2","OG3"))
```

```{r,save all OG objects}
saveRDS(suture_mes_mito_MAGIC_OG0, file = "./SeuratObject/suture_mes_mito_MAGIC_OG0_0430.rds")
saveRDS(suture_mes_mito_MAGIC_OG1, file = "./SeuratObject/suture_mes_mito_MAGIC_OG1_0430.rds")
saveRDS(suture_mes_mito_MAGIC_OG2, file = "./SeuratObject/suture_mes_mito_MAGIC_OG2_0430.rds")
saveRDS(suture_mes_mito_MAGIC_OG3, file = "./SeuratObject/suture_mes_mito_MAGIC_OG3_0430.rds")
saveRDS(suture_mes_mito_MAGIC_OG, file = "./SeuratObject/suture_mes_mito_MAGIC_OG_0430.rds")
```

Split OG3 object by group
```{r, split by group}
#suture_mes_mito_MAGIC_OG3_object_list <- SplitObject(suture_mes_mito_MAGIC_OG3, split.by = "group")
#suture_mes_mito_MAGIC_OG3_SAG <- suture_mes_mito_MAGIC_OG3_object_list$SAG
#suture_mes_mito_MAGIC_OG3_PF <- suture_mes_mito_MAGIC_OG3_object_list$PF
```


# 5 DEG heatmap for OG3
Since OG3 cluster displayed similar trend as we saw in the differet rescue effect, we want to figure out what happened in this cluster.
This cluster is associated with terminal differentiated osteoblasts, but who regulate their fate?
## 5.1 Load data

```{r,Load packages and datasets}
gc()
rm(list=ls())
suture_mes_mito_MAGIC_OG <- readRDS(file = "./SeuratObject/suture_mes_mito_MAGIC_OG_0430.rds")
```

## 5.2 Prepare DEGs RNA in OG3 in OG population
##5.2.1 DEG gene names
```{r}
suture_mes_mito_MAGIC_OG$celltype.group <- paste(suture_mes_mito_MAGIC_OG$celltype, suture_mes_mito_MAGIC_OG$orig.ident, sep = "_")
suture_mes_mito_MAGIC_OG$celltype <- Idents(suture_mes_mito_MAGIC_OG)
Idents(suture_mes_mito_MAGIC_OG) <- "celltype.group"
table(suture_mes_mito_MAGIC_OG$celltype.group)
```

```{r}
cellfordeg<-as.factor(rownames(table(suture_mes_mito_MAGIC_OG$orig.ident)))
cellfordeg
```

Generate and harvest the top20 changed genes among different gennotypes. Based on RNA data
```{r}
DefaultAssay(suture_mes_mito_MAGIC_OG) <- "RNA"
n <- length(cellfordeg)  # get the length of the list
for (i in 1:(n-1)) {  # iterate through all pairs of elements
  for (j in (i+1):n) {
    CELLDEG_OG3 <- FindMarkers(suture_mes_mito_MAGIC_OG, ident.1 = paste0("OG3_", cellfordeg[[i]]), ident.2 = paste0("OG3_",cellfordeg[[j]]), verbose = FALSE)
    top10 <- CELLDEG_OG3 %>% top_n(n = 20, wt = avg_log2FC) # You may change n=20 to other number to get top_n genes as you wish.
    write.csv(top10,paste0("OG3_", cellfordeg[i],"_", cellfordeg[[j]] ,"_RNA_top20_0430.CSV"))
  }
}

```

Gather all DEs for OG3
```{r}
# list all the CSV files in the directory
files <- list.files(pattern = "*_RNA_top20.CSV")
# create an empty list to store the dataframes
unique_vals <- list()
# loop through each file and read it into a dataframe and add it to the list
for (file in files) {
  df <- read.csv(file, stringsAsFactors = FALSE)
  unique_vals[[file]] <- unique(df[,1])
}


# combine all the unique values into one vector and remove duplicates
unique_first_col <- unique(unlist(unique_vals))
```

```{r}
OG3_DE_RNA <- as.factor(unique_first_col)
```


## 5.2.2 Seurat for DEs in OG3
Here we subset the OG3 object using all the DEs in OG3.

```{r}

suture_mes_mito_MAGIC_OG3_DE <- subset(suture_mes_mito_MAGIC_OG, features = OG3_DE_RNA)
Idents(suture_mes_mito_MAGIC_OG3_DE) <- "celltype"
suture_mes_mito_MAGIC_OG3_DE <- subset(suture_mes_mito_MAGIC_OG3_DE, idents = "OG3")
```

Here, we extracted the expression matrix based on MAGIC imputation
```{r}
suture_mes_mito_MAGIC_OG3_DE_matrix <- suture_mes_mito_MAGIC_OG3_DE@assays$MAGIC_SCT@data
```

Remove the barcode information
```{r}
colnames(suture_mes_mito_MAGIC_OG3_DE_matrix) <- gsub("WT_SAG.*", "WT_SAG",colnames(suture_mes_mito_MAGIC_OG3_DE_matrix))
colnames(suture_mes_mito_MAGIC_OG3_DE_matrix) <- gsub("KO_SAG.*", "KO_SAG",colnames(suture_mes_mito_MAGIC_OG3_DE_matrix))
colnames(suture_mes_mito_MAGIC_OG3_DE_matrix)<- gsub("Runx2_SAG.*", "Runx2_SAG",colnames(suture_mes_mito_MAGIC_OG3_DE_matrix))
colnames(suture_mes_mito_MAGIC_OG3_DE_matrix) <- gsub("DM_SAG.*", "DM_SAG",colnames(suture_mes_mito_MAGIC_OG3_DE_matrix))

colnames(suture_mes_mito_MAGIC_OG3_DE_matrix) <- gsub("WT_PF.*", "WT_PF",colnames(suture_mes_mito_MAGIC_OG3_DE_matrix))
colnames(suture_mes_mito_MAGIC_OG3_DE_matrix) <- gsub("KO_PF.*", "KO_PF",colnames(suture_mes_mito_MAGIC_OG3_DE_matrix))
colnames(suture_mes_mito_MAGIC_OG3_DE_matrix)<- gsub("Runx2_PF.*", "Runx2_PF",colnames(suture_mes_mito_MAGIC_OG3_DE_matrix))
colnames(suture_mes_mito_MAGIC_OG3_DE_matrix) <- gsub("DM_PF.*", "DM_PF",colnames(suture_mes_mito_MAGIC_OG3_DE_matrix))
```

Generate matrix

```{r}
df <- (as.matrix(suture_mes_mito_MAGIC_OG3_DE_matrix))
df[1:3, 1:5]
```
Here, we want to check the number and sequence of the 8 genotype_tissue
```{r}

# Convert the first row of the matrix into a factor variable
factors <- factor(colnames(df), levels = unique(colnames(df)))


# Get the unique factor sequences and their frequencies
unique_seqs <- table(factors)

# Print the unique factor sequences and their frequencies
cat("Unique factor sequences:\n")
for (i in seq_along(unique_seqs)) {
  cat("\t", names(unique_seqs)[i], ": ", unique_seqs[i], "\n")
}

#WT_PF :  250 
#WT_SAG :  361 
#Runx2_PF :  279 
#Runx2_SAG :  60 
#KO_PF :  190 
#KO_SAG :  557 
#DM_PF :  127 
#DM_SAG :  267 
```
Unique factor sequences:
	 WT_PF :  248 
	 WT_SAG :  357 
	 Runx2_PF :  284 
	 Runx2_SAG :  61 
	 KO_PF :  191 
	 KO_SAG :  545 
	 DM_PF :  129 
	 DM_SAG :  268 
We want to reorder them as ("WT_PF", "Runx2_PF", "KO_PF", "DM_PF", "WT_SAG", "Runx2_SAG", "KO_SAG","DM_SAG")
```{r}
dim(df)
# Define the new order of column names
new_order <- c(rep("WT_PF", 248), rep("Runx2_PF", 284), rep("KO_PF", 191), rep("DM_PF", 129),
               rep("WT_SAG", 357), rep("Runx2_SAG", 61), rep("KO_SAG", 545), rep("DM_SAG", 268))


# Reorder the columns of the matrix
df_reordered <- df[, order(match(colnames(df), new_order))]

dim(df_reordered)
```

```{r}
df_reordered[1:3, 1:5]
# Since these column are with same colname, we want to make them unique.
colnames(df_reordered) <- c(paste0("WT_PF_", 1:248), paste0("Runx2_PF_", 1:284), paste0("KO_PF_", 1:191), paste0("DM_PF_", 1:129), paste0("WT_SAG_", 1:357), paste0("Runx2_SAG_", 1:61), paste0("KO_SAG_", 1:545), paste0("DM_SAG_", 1:268))


```

Generate an annotation dataframe to annotate each column
```{r}
annotation_col = data.frame(
  group = c(rep("WT_PF", 248), rep("Runx2_PF", 284), rep("KO_PF", 191), rep("DM_PF", 129),
               rep("WT_SAG", 357), rep("Runx2_SAG", 61), rep("KO_SAG", 545), rep("DM_SAG", 268))
  
)
row.names(annotation_col) <- colnames(df_reordered)
```
Generate an annotation dataframe for color
```{r}
groupcolor <- c("#FF5733","#FFC300","#FF4081","#7B1FA2",
                '#4CAF50','#2196F3','#795548','#2C427E') 
names(groupcolor) <- c("WT_PF","Runx2_PF","KO_PF","DM_PF",
                       "WT_SAG","Runx2_SAG","KO_SAG","DM_SAG") # group id

ann_colors <- list(group=groupcolor) #You may add more catergories according to your designn
```


```{r}
dim(df_reordered)
ph_cluster_test <- function(x,j){
  n=t(scale(t(x)))
  head(n)
  n[n>4]=4 #Set upper limit, values greater than 4 equal to 4
  n[n< -4]= -4 #Set lower limit, values less than -4 equal to -4
  head(n)
  n[1:4,1:4]
  m<- paste(x,"_ph",sep = "_")
  m<-pheatmap(n,cluster_rows = T,cluster_cols = F,
              color=colorRampPalette(c("navy","white","firebrick3"))(100),
              show_colnames = F,border_color = NA,show_rownames =T,
              annotation_col = annotation_col,
              annotation_colors = ann_colors,
              cutree_row = j, cutree_cols = 5)
  m
  return(m)
}

```


```{r,fig.height=25, fig.width=10}
library(pheatmap)

tdf_test<-ph_cluster_test(df_reordered,12)

```

```{r}
write.csv(df_reordered,file="suture_mes_mito_MAGIC_OG3_DEG_RNA_matrix.csv",row.names = TRUE)
```
However, the above approches were too arbitrary, which lead us to tink whether k-mean cluster will give us more reasonable results.

## 5.3 k-mean
## 5.3.1 k-mean cluster
```{r}
# --- 1. Load necessary packages ---
# install.packages(c("dplyr", "tidyr", "ggplot2", "factoextra")) # If not installed, uncomment and run
library(dplyr)
library(tidyr)
library(ggplot2)
library(factoextra) # For visualization and help with selecting k
library(stats)     # For kmeans

# --- Assume df_reordered has been loaded into your R environment ---
df_reordered <- read.csv(file = "suture_mes_mito_MAGIC_OG3_DEG_RNA_matrix.csv")
# First determine the source of gene names and data columns
gene_names_source <- NULL
data_columns <- NULL

# Check if the first column looks like gene names (non-numeric), and subsequent columns are numeric
if ((is.character(df_reordered[[1]]) || is.factor(df_reordered[[1]])) && all(sapply(df_reordered[, -1, drop = FALSE], is.numeric))) {
  cat("Method 1: Assume first column is gene names, rest are numeric.\n")
  gene_names_source <- as.character(df_reordered[[1]]) # Ensure it's character
  data_columns <- df_reordered[, -1, drop = FALSE]
} else if (is.character(rownames(df_reordered)) && all(sapply(df_reordered, is.numeric))) {
  cat("Method 2: Assume row names are gene names, all columns are numeric.\n")
  gene_names_source <- rownames(df_reordered)
  data_columns <- df_reordered
} else {
   # Try a more general approach: first column is gene names, try to convert other columns
   if (is.character(df_reordered[[1]]) || is.factor(df_reordered[[1]])) {
       cat("Method 3: Assume first column is gene names, try to convert rest to numeric.\n")
       gene_names_source <- as.character(df_reordered[[1]])
       # Try to convert
       data_columns_temp <- df_reordered[, -1, drop = FALSE]
       # Use lapply to convert, handle possible non-numeric column errors
       df_numeric_list <- lapply(data_columns_temp, function(col) {
           suppressWarnings(as.numeric(as.character(col))) # Convert to character then numeric, handle factors etc
       })
       data_columns <- as.data.frame(df_numeric_list)

       # Check ( NA )
       all_numeric <- all(sapply(data_columns, is.numeric))
       if (!all_numeric) {
           warning("Not all non-gene name columns could be successfully converted to numeric.")
       }
   } else {
        stop("Unable to automatically determine gene name column or all columns are already numeric. Please Check df_reordered structure.")
   }
}

# CheckExtract
if (is.null(gene_names_source) || is.null(data_columns)) {
    stop("Failed to successfully separate gene names and data columns.")
}

print("Preliminary check gene name source:")
print(paste("Number of potential gene names:", length(gene_names_source)))
print(paste("Number of rows in data columns:", nrow(data_columns)))
if (length(gene_names_source) != nrow(data_columns)) {
    stop("After extraction, gene name count does not match data row count, please check original data structure.")
}

print("Check duplicates in gene name source:")
if (any(duplicated(gene_names_source))) {
  warning("Duplicate!")
  print(head(gene_names_source[duplicated(gene_names_source)]))
  #  make.unique
  # gene_names_source <- make.unique(gene_names_source)
  # cat(" make.unique Duplicate\n")
  stop("DetectDuplicate")
}

print("Check NA values in gene name source:")
if (any(is.na(gene_names_source))) {
  warning("NA!")
  # Remove
  stop("DetectNA")
}

#  data_columns 
df_numeric <- data_columns

# Final check and set row names
if (length(gene_names_source) == nrow(df_numeric)) {
  rownames(df_numeric) <- gene_names_source
  cat("\n")
} else {
  # Theoryshould notoccurbecausepreviousalreadyCheckoncebut asfinalinsurance
  stop(paste(" (", length(gene_names_source),
             ")  (", nrow(df_numeric),
             ") "))
}

# --- nextcodeCheckNAcalculatemean---

# CheckNA
if (any(is.na(df_numeric))) {
  warning("NA")
  # RemoveNA
  na_rows <- apply(df_numeric, 1, function(row) any(is.na(row)))
  if(any(na_rows)) {
      cat("Remove", sum(na_rows), "becauseNA\n")
      df_numeric <- df_numeric[!na_rows, , drop = FALSE]
      # EnsureRemove
       if(nrow(df_numeric) == 0) {
           stop("NARemove")
       }
  }
}

#  df_numeric 
print(" df_numeric :")
print(dim(df_numeric))
print(" df_numeric :")
print(head(rownames(df_numeric)))
print(" df_numeric :")
print(head(df_numeric[, 1:min(ncol(df_numeric), 5)])) # 



# --- 2.  - calculatemean ---
# Define
group_info <- list(
  WT_PF = 248, WT_SAG = 357, Runx2_PF = 284, Runx2_SAG = 61,
  KO_PF = 191, KO_SAG = 545, DM_PF = 129, DM_SAG = 268
)
group_names <- names(group_info)

# mean
group_means_list <- list()

# 
for (group in group_names) {
  #  ( startsWith  grep)
  group_cols <- grep(paste0("^", group, "_"), colnames(df_numeric), value = TRUE)

  if (length(group_cols) > 0) {
    # calculatemean (rowMeans)
    group_means_list[[group]] <- rowMeans(df_numeric[, group_cols, drop = FALSE], na.rm = TRUE)
  } else {
    warning(paste("", group, ""))
  }
}

# 
df_means <- as.data.frame(do.call(cbind, group_means_list))

# Checkcalculatemean
print(":")
head(df_means)
print(dim(df_means))

# --- 3.  ---
#  Z-score 
# scale() function ->  -> 
df_means_scaled <- t(scale(t(df_means)))

# Checkbecause0NaN
if(any(is.nan(df_means_scaled))) {
    warning("NaNbecauseRemove")
    genes_to_keep <- rownames(df_means_scaled)[apply(df_means_scaled, 1, function(x) !any(is.nan(x)))]
    df_means_scaled <- df_means_scaled[genes_to_keep, , drop = FALSE]
    df_means <- df_means[genes_to_keep, , drop = FALSE] # 
    if(nrow(df_means_scaled) == 0) {
      stop("NaN")
    }
}

# Check
print(":")
head(df_means_scaled)
desired_column_order <- c("WT_PF", "Runx2_PF", "KO_PF", "DM_PF",
                          "WT_SAG", "Runx2_SAG", "KO_SAG", "DM_SAG")
df_means_scaled <- df_means_scaled[, desired_column_order, drop = FALSE]
head(df_means_scaled)
write.csv(df_means_scaled, file = "suture_mes_mito_MAGIC_OG3_DEG_RNA_normalized.csv",row.names = FALSE)
```
```{r}
# --- 4.  (k) ---
#  Elbow Method  Silhouette Method
# 

# k ()
max_k <- 15
```

```{r}
# 
set.seed(123) # Duplicate
elbow_plot <- fviz_nbclust(df_means_scaled, kmeans, method = "wss", k.max = max_k) +
   labs(subtitle = "Elbow method")
 print(elbow_plot)

# 
# set.seed(123)
silhouette_plot <- fviz_nbclust(df_means_scaled, kmeans, method = "silhouette", k.max = max_k) + labs(subtitle = "Silhouette method")

print(silhouette_plot)
```

```{r}
#  k 
# 
#  k = 4 ()
optimal_k <- 10 # <--- !

cat(paste(" k =", optimal_k, "\n"))

# --- 5.  K-means  ---
set.seed(123) # Duplicate
kmeans_result <- kmeans(df_means_scaled, centers = optimal_k, nstart = 25) # nstart 

# 
print(kmeans_result)

# mean
df_means$cluster <- kmeans_result$cluster
df_means_scaled_with_cluster <- as.data.frame(df_means_scaled)
df_means_scaled_with_cluster$cluster <- kmeans_result$cluster

# 
cat(":\n")
print(table(df_means$cluster))
write.csv(df_means_scaled_with_cluster,file = "suture_mes_mito_MAGIC_OG3_DEG_RNA_clustered_10.csv",row.names = TRUE )

```

```{r}
# --- 6.  (EnsureX) ---

# --- DefineX ---
# X
desired_group_order <- c("WT_PF", "Runx2_PF", "KO_PF", "DM_PF",
                         "WT_SAG", "Runx2_SAG", "KO_SAG", "DM_SAG")

# ---  ---
#  df_means_scaled_with_cluster already 'cluster' 
# 
# ( 'gene' If 'cluster' )
group_columns_to_pivot <- setdiff(colnames(df_means_scaled_with_cluster), "cluster")
# If 'gene'  'gene'
# Ifalready 'gene' :
if ("gene" %in% colnames(df_means_scaled_with_cluster)) {
  group_columns_to_pivot <- setdiff(group_columns_to_pivot, "gene")
}

# --- CheckEnsure ---
# 
if (!all(desired_group_order %in% group_columns_to_pivot) ||
    !all(group_columns_to_pivot %in% desired_group_order)) {
      warning(paste(":  (desired_group_order) ",
                    "df_means_scaled_with_cluster ",
                    " desired_group_order "))
      # Ensure
      group_columns_to_pivot <- intersect(desired_group_order, group_columns_to_pivot)
} else {
    # IfEnsure pivot  desired_group_order 
    #  pivot_longer 
    group_columns_to_pivot <- desired_group_order
}


# ---  ggplot  ---
df_plot_data <- df_means_scaled_with_cluster %>%
  # If 'gene' 
  # Ifalready 'gene'  if 
  #  'gene' 
  tibble::rownames_to_column("gene") %>%
  # 
  pivot_longer(cols = all_of(group_columns_to_pivot), #  all_of Ensure
               names_to = "group",
               values_to = "scaled_expression") %>%
  # ***  desired_group_order  ***
  mutate(group = factor(group, levels = desired_group_order))

# --- Check ---
cat("'group' (desired_group_order):\n")
print(levels(df_plot_data$group))

# ---  ---
# Ensure optimal_k  k  ( 2  3)
# IfDefine optimal_k <- 2
if (!exists("optimal_k")) {
  warning(" 'optimal_k' Define k  NA optimal_k")
  optimal_k <- NA # 
}

cluster_trend_plot <- ggplot(df_plot_data, aes(x = group, y = scaled_expression, group = gene)) +
  geom_line(alpha = 0.1, color = "grey") + # 
  stat_summary(aes(group = 1), fun = mean, geom = "line", color = "red", size = 1) + # 
  facet_wrap(~ cluster, scales = "free_y") + # 
  theme_minimal() +
  labs(
    title = "Gene Expression Trends by Cluster (Scaled)",
    x = "Sample Group (Custom Order)", # X
    y = "Scaled Mean Expression (Z-score)",
    caption = paste("K-means clustering with k =", optimal_k)
  ) +
  theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8)) # 

print(cluster_trend_plot)

# 
ggsave("gene_cluster_trends_custom_order.pdf", plot = cluster_trend_plot, width = 11, height = 8)

# 
# Ensure
#  df_means_scaled_with_cluster  df_means_scaled  cluster 
if(exists("df_means_scaled") && nrow(df_means_scaled) == nrow(df_means_scaled_with_cluster) && all(rownames(df_means_scaled) == rownames(df_means_scaled_with_cluster))) {
    cluster_gene_list <- split(rownames(df_means_scaled), df_means_scaled_with_cluster$cluster)
    # print(head(cluster_gene_list[[1]])) # 
} else if (exists("df_means") && nrow(df_means) == nrow(df_means_scaled_with_cluster) && all(rownames(df_means) == rownames(df_means_scaled_with_cluster))) {
     cluster_gene_list <- split(rownames(df_means), df_means_scaled_with_cluster$cluster)
     # print(head(cluster_gene_list[[1]]))
} else {
    warning(" df_means_scaled_with_cluster  df_means  df_means_scaled Extract")
    cluster_gene_list <- list() # 
}


# 
# If df_means_scaled_with_cluster  'gene' 
# write.csv  row.names=TRUE  'gene' 
write.csv(df_means_scaled_with_cluster, file = "gene_expression_scaled_means_with_clusters.csv")
```

```{r,save cluster information}

# 1. 
#     "Gene" 
#     'cluster'  "Cluster" code
cluster_info_to_save <- data.frame(
  Gene = rownames(df_means_scaled_with_cluster),
  Cluster = df_means_scaled_with_cluster$cluster
)

# 2. Define CSV 
csv_filename <- "suture_mes_mito_MAGIC_OG3_DEG_clusterinfo_10.csv"

# 3.  CSV 
#    row.names = FALSE 1, 2, 3...
#    quote = FALSE 
write.csv(cluster_info_to_save, file = csv_filename, row.names = FALSE, quote = FALSE)

cat(paste("Cluster information successfully saved to:", csv_filename, "\n"))
```

## 5.3.2 avg cluster

```{r}
# --- 1. Install/Load Packages ---
# install.packages("pheatmap")
# install.packages("RColorBrewer") # For cluster colors (optional)
library(pheatmap)
library(dplyr)
library(tidyr)
library(tibble)
library(RColorBrewer) # Optional: for nice cluster colors

# --- Assuming df_plot_data exists from previous steps ---
# Verify structure: should have gene, cluster, group, scaled_expression
print("Input data (df_plot_data) head:")
head(df_plot_data)

# --- 2. Define Group Order and Colors ---
desired_group_order <- c("WT_PF","Runx2_PF","KO_PF","DM_PF",
                         "WT_SAG","Runx2_SAG","KO_SAG","DM_SAG")

groupcolor <- c("#FF5733","#FFC300","#FF4081","#7B1FA2",
                '#4CAF50','#2196F3','#795548','#2C427E')
names(groupcolor) <- desired_group_order # Ensure names match the desired order

# --- 3. Define Heatmap Body Color Scale ---
heatmap_colors <- colorRampPalette(c("navy", "white", "firebrick3"))(100)

# --- 4. Reshape Data to Wide Matrix ---
# We need a matrix where rows are genes and columns are groups

# First, ensure df_plot_data only contains the groups we want in the desired order
df_plot_data_filtered <- df_plot_data %>%
    filter(group %in% desired_group_order) %>%
    # This step ensures the 'group' factor levels are correct before pivoting
    mutate(group = factor(group, levels = desired_group_order))

# Pivot to wide format
heatmap_matrix_df <- df_plot_data_filtered %>%
  select(gene, group, scaled_expression) %>% # Keep only necessary columns
  pivot_wider(names_from = group, values_from = scaled_expression)

# Convert to matrix and set row names
heatmap_matrix <- as.matrix(heatmap_matrix_df %>% column_to_rownames("gene"))

# Verify matrix dimensions and column order
print("Dimensions of heatmap matrix:")
print(dim(heatmap_matrix)) # Should be [number_of_genes x 8]
print("Column names of heatmap matrix (should match desired order):")
print(colnames(heatmap_matrix)) # Should be WT_PF, Runx2_PF, ..., DM_SAG

# --- 5. Prepare Row Annotation (Clusters) ---
# Get unique gene-cluster mapping
row_annotation_df <- df_plot_data %>%
  select(gene, cluster) %>%
  distinct() %>%
  # Ensure it's sorted in the same order as the matrix rows will be
  arrange(cluster, gene) %>%
  # Set row names to gene for matching with the matrix
  column_to_rownames("gene") %>%
  # Convert cluster to factor for coloring purposes
  mutate(cluster = factor(cluster))

# --- 6. Sort the Matrix Rows based on Cluster ---
# Ensure the matrix rows are in the same order as the row annotation (sorted by cluster, then gene)
heatmap_matrix_sorted <- heatmap_matrix[rownames(row_annotation_df), , drop = FALSE]

# Verify sorting
# print(head(rownames(heatmap_matrix_sorted)))
# print(head(rownames(row_annotation_df)))

# --- 7. Prepare Column Annotation (Groups) ---
col_annotation_df <- data.frame(Group = factor(colnames(heatmap_matrix_sorted), levels = desired_group_order))
rownames(col_annotation_df) <- colnames(heatmap_matrix_sorted)

# --- 8. Define Annotation Colors ---
# Assign colors to clusters (adjust if you have more/fewer clusters than Brewer palettes support)
num_clusters <- nlevels(row_annotation_df$cluster)
# Use a Brewer palette (e.g., Set1, Set2, Paired) or create manually
if (num_clusters <= 9 && num_clusters >= 3) {
    cluster_colors_palette <- brewer.pal(num_clusters, "Set1")
} else if (num_clusters > 9) {
    # If more than 9 clusters, Brewer palettes might repeat; use a different method or palette
    # Using rainbow as an example for many clusters
    cluster_colors_palette <- rainbow(num_clusters)
} else { # Handle cases with 1 or 2 clusters
    cluster_colors_palette <- brewer.pal(max(3, num_clusters), "Set1")[1:num_clusters]
}
cluster_colors <- cluster_colors_palette
names(cluster_colors) <- levels(row_annotation_df$cluster)


# Create the list for pheatmap
annotation_colors_list <- list(
  Group = groupcolor,      # From user input
  cluster = cluster_colors # Defined above
)

# --- 9. Calculate Gaps for Separating Clusters ---
# Find where the cluster changes in the sorted row annotation
cluster_changes <- which(diff(as.numeric(row_annotation_df$cluster)) != 0)
# cluster_changes will be the row indices *before* the change occurs

# --- 10. Plot Heatmap ---
# It's often best *not* to show rownames if there are many genes
pheatmap_plot <- pheatmap(
  heatmap_matrix_sorted,
  color = heatmap_colors,
  annotation_row = row_annotation_df,
  annotation_col = col_annotation_df,
  annotation_colors = annotation_colors_list,
  cluster_rows = FALSE, # We already sorted rows by cluster
  cluster_cols = FALSE, # We want columns in our desired order
  show_rownames = FALSE, # Set to TRUE if you have few genes
  show_colnames = TRUE,
  gaps_row = cluster_changes, # Add lines between clusters
  border_color = "grey60", # Optional: adds cell borders
  main = "Gene Expression Heatmap by Cluster" # Optional: add a title
  # You might need to adjust scale="row" or scale="none" depending on your data
  # Since data is already scaled (df_means_scaled), use scale="none" (default)
)

# If you need to save the plot, pheatmap usually draws directly.
# You might need to wrap it in png(), pdf() etc.
pdf("suture_mes_mito_MAGIC_OG3_DEG_avg_heatmap.pdf", width = 8, height = 10)
pheatmap(
  heatmap_matrix_sorted,
  color = heatmap_colors,
  annotation_row = row_annotation_df,
  annotation_col = col_annotation_df,
  annotation_colors = annotation_colors_list,
  cluster_rows = FALSE, # We already sorted rows by cluster
  cluster_cols = FALSE, # We want columns in our desired order
  show_rownames = FALSE, # Set to TRUE if you have few genes
  show_colnames = TRUE,
  gaps_row = cluster_changes, # Add lines between clusters
  border_color = "grey60", # Optional: adds cell borders
  main = "Gene Expression Heatmap by Cluster" # Optional: add a title
  # You might need to adjust scale="row" or scale="none" depending on your data
  # Since data is already scaled (df_means_scaled), use scale="none" (default)
)
dev.off()

print("Heatmap generation complete.")

# The plot object `pheatmap_plot` can sometimes be used, but pheatmap often draws directly.
```


##5.3.3 scRNA heatmap
```{r}
# --- 0.  ---
rm(list = ls())

# --- 1.  ---
# install.packages(c("pheatmap", "dplyr", "tibble", "RColorBrewer")) # If
library(pheatmap)
library(dplyr)
library(tibble)
library(RColorBrewer)

cat("--- Script Start ---\n")
loaded_assignments_df <- read.csv("suture_mes_mito_MAGIC_OG3_DEG_clusterinfo_10.csv", stringsAsFactors = FALSE)
# If
gene_cluster_map <- setNames(loaded_assignments_df$Cluster, loaded_assignments_df$Gene)
print(head(gene_cluster_map))
# --- 2.  ---
file_path <- "suture_mes_mito_MAGIC_OG3_DEG_RNA_matrix.csv" # Ensure
cat(paste("Loading data from:", file_path, "\n"))
if (!file.exists(file_path)) {
  stop("Error: Input CSV file not found at specified path.")
}
# :  1 
df_reordered_raw <- read.csv(
    file = file_path,
    header = TRUE,
    stringsAsFactors = FALSE,
    check.names = FALSE,
    row.names = 1 # Use first column from CSV as row names
    )

cat("--- Initial Data Check (after loading with row.names=1) ---\n")
print(paste("Class:", class(df_reordered_raw)))
print(paste("Dimensions:", paste(dim(df_reordered_raw), collapse=" x ")))
print("Head of Rownames (should be gene names):")
print(head(rownames(df_reordered_raw)))
print("Head of first 5 columns:")
print(head(df_reordered_raw[, 1:min(5, ncol(df_reordered_raw))]))

# --- 3. Ensure ---
cat("Preparing numeric matrix...\n")
if (all(sapply(df_reordered_raw, is.numeric))) {
    df_ready_for_scaling <- as.matrix(df_reordered_raw)
    cat("All columns numeric. Converted data frame to matrix.\n")
} else {
    warning("Some data columns were not numeric. Attempting conversion...")
    original_rownames <- rownames(df_reordered_raw)
    df_ready_for_scaling <- suppressWarnings(as.matrix(sapply(df_reordered_raw, function(x) as.numeric(as.character(x)))))
    rownames(df_ready_for_scaling) <- original_rownames
    if(!is.numeric(df_ready_for_scaling)) stop("Failed to convert non-numeric columns.")
    # Check for NA rows resulting from conversion
    rows_all_na <- apply(df_ready_for_scaling, 1, function(r) all(is.na(r)))
     if(any(rows_all_na)){
         warning("Removing rows that became all NA after numeric conversion.")
         df_ready_for_scaling <- df_ready_for_scaling[!rows_all_na, , drop=FALSE]
         if(nrow(df_ready_for_scaling) == 0) stop("All rows became NA after conversion.")
     }
    cat("Converted columns to numeric and created matrix.\n")
}
# Check
cat("--- Prepared Matrix Check (df_ready_for_scaling) ---\n")
print(paste("Class:", class(df_ready_for_scaling)))
print(paste("Dimensions:", paste(dim(df_ready_for_scaling), collapse=" x ")))
print("Row names head:")
print(head(rownames(df_ready_for_scaling))) # 


# --- 4. Z-score standardization and upper/lower limit setting (with name protection) ---
cat("\n--- Applying Z-score Scaling and Capping ---\n")
x_matrix <- df_ready_for_scaling

# 
original_rownames <- rownames(x_matrix)
original_colnames <- colnames(x_matrix)
if(is.null(original_rownames) || length(original_rownames) != nrow(x_matrix)) stop("Invalid row names before scaling.")
cat("Saved original row/column names.\n")

# 
cat("Performing row-wise Z-score scaling...\n")
scaled_matrix_values <- t(scale(t(x_matrix)))

# Check
if(!identical(dim(scaled_matrix_values), dim(x_matrix))) stop("Dimension mismatch after scaling.")

# 
rownames(scaled_matrix_values) <- original_rownames
colnames(scaled_matrix_values) <- original_colnames
scaled_matrix <- scaled_matrix_values
cat("Restored names after scaling.\n")

# Check NaN ()
nan_rows_mask <- apply(scaled_matrix, 1, function(row) any(is.nan(row)))
valid_genes_after_scaling <- rownames(scaled_matrix)[!nan_rows_mask] # 
if (any(nan_rows_mask)) {
  num_nan_rows <- sum(nan_rows_mask)
  warning(sprintf("Removing %d rows with zero variance during scaling (resulted in NaN).", num_nan_rows))
  scaled_matrix <- scaled_matrix[!nan_rows_mask, , drop = FALSE]
  if(nrow(scaled_matrix) == 0) stop("All rows removed due to zero variance.")
  valid_genes_after_scaling <- rownames(scaled_matrix) # 
  cat("NaN rows removed. Remaining dimensions:", paste(dim(scaled_matrix), collapse=" x "), "\n")
} else { cat("No rows with zero variance found during scaling.\n") }

#  Capping
cap_limit <- 4
scaled_matrix[scaled_matrix > cap_limit] <- cap_limit
scaled_matrix[scaled_matrix < -cap_limit] <- -cap_limit
heatmap_matrix_prepared <- scaled_matrix
cat("Capping applied.\n")

cat("--- Matrix Check After Scaling/Capping ---\n")
print(paste("Dimensions:", paste(dim(heatmap_matrix_prepared), collapse=" x ")))
print("Row names head:")
print(head(rownames(heatmap_matrix_prepared))) # 


# --- 5.  () ---
cat("\n--- Preparing Row Annotation (Cluster Info) ---\n")
# !!! Placeholder:  gene -> cluster  !!!
#  'gene_cluster_map' (: names=, values=cluster)
# ----------------------------------------------------------
# :  ()
if (!exists("gene_cluster_map")) {
    if (exists("df_means_scaled") && exists("optimal_k")) {
         cat("Cluster map not found. Re-running k-means on df_means_scaled with optimal_k =", optimal_k, "...\n")
         common_genes_for_kmeans <- intersect(rownames(df_means_scaled), rownames(heatmap_matrix_prepared))
         if (length(common_genes_for_kmeans) < optimal_k) stop("Not enough common genes between df_means_scaled and prepared matrix for k-means.")
         df_means_scaled_subset <- df_means_scaled[common_genes_for_kmeans, ]
         set.seed(123)
         kmeans_result_placeholder <- kmeans(df_means_scaled_subset, centers = optimal_k, nstart = 25)
         gene_cluster_map <- kmeans_result_placeholder$cluster # 
         warning("Used k-means result based on 'df_means_scaled' and 'optimal_k'.")
    } else {
         stop("Error: Need gene-to-cluster mapping. Please provide 'gene_cluster_map' (named vector: names=genes, values=clusters).")
         # #  ():
         # warning("Creating DUMMY cluster assignments for testing.")
         # optimal_k <- 4
         # gene_cluster_map <- setNames(sample(1:optimal_k, nrow(heatmap_matrix_prepared), replace = TRUE), rownames(heatmap_matrix_prepared))
    }
}
# ----------------------------------------------------------

# Ensure gene_cluster_map  heatmap_matrix_prepared 
genes_in_matrix <- rownames(heatmap_matrix_prepared)
genes_in_map <- names(gene_cluster_map)
common_genes_annot <- intersect(genes_in_matrix, genes_in_map)
if(length(common_genes_annot) == 0) stop("No common genes between matrix and cluster map.")
if(length(common_genes_annot) < length(genes_in_matrix)){
    warning("Some genes in the matrix are missing from the cluster map. They will be excluded from the heatmap.")
    heatmap_matrix_prepared <- heatmap_matrix_prepared[common_genes_annot, , drop=FALSE] # 
}

# 
row_annotation_df <- data.frame(
  row.names = common_genes_annot, # Ensure
  cluster = factor(gene_cluster_map[common_genes_annot]) # Extractcluster
)

#  ( cluster,  gene name)
cat("Sorting rows by cluster...\n")
row_order_indices <- order(row_annotation_df$cluster, rownames(row_annotation_df))
row_annotation_df_sorted <- row_annotation_df[row_order_indices, , drop = FALSE]


# --- 6.  ---
heatmap_matrix_sorted_rows <- heatmap_matrix_prepared[rownames(row_annotation_df_sorted), , drop = FALSE]


# --- 7.  ---
cat("Preparing column annotation and sorting columns...\n")
desired_group_order <- c("WT_PF","Runx2_PF","KO_PF","DM_PF",
                         "WT_SAG","Runx2_SAG","KO_SAG","DM_SAG")
groupcolor <- c(WT_PF="#FF5733", Runx2_PF="#FFC300", KO_PF="#FF4081", DM_PF="#7B1FA2",
                WT_SAG='#4CAF50', Runx2_SAG='#2196F3', KO_SAG='#795548', DM_SAG='#2C427E')
if(!identical(names(groupcolor), desired_group_order)) warning("Names of groupcolor do not match desired_group_order!")

# Extract
sample_names <- colnames(heatmap_matrix_sorted_rows)
group_mapping <- gsub("_\\d+$", "", sample_names)
if (!all(group_mapping %in% desired_group_order)) warning("Some sample names did not map to expected groups.")

#  DF
col_annotation_df <- data.frame(Group = factor(group_mapping, levels = desired_group_order))
rownames(col_annotation_df) <- sample_names

# 
ordered_sample_indices <- order(factor(group_mapping, levels = desired_group_order))
ordered_sample_names <- sample_names[ordered_sample_indices]

# 
heatmap_matrix_final <- heatmap_matrix_sorted_rows[, ordered_sample_names, drop = FALSE]
col_annotation_df_ordered <- col_annotation_df[ordered_sample_names, , drop = FALSE]


# --- 8. Define ---
cat("Defining annotation colors...\n")
num_clusters <- nlevels(row_annotation_df_sorted$cluster)
#  cluster 
if (!exists("cluster_colors") || length(cluster_colors) != num_clusters) {
    if (num_clusters <= 9 && num_clusters >=3) { cluster_colors_palette <- brewer.pal(num_clusters, "Set1") }
    else if (num_clusters > 9) { cluster_colors_palette <- rainbow(num_clusters) }
    else { cluster_colors_palette <- brewer.pal(max(3, num_clusters), "Set1")[1:num_clusters] }
    cluster_colors <- cluster_colors_palette
    names(cluster_colors) <- levels(row_annotation_df_sorted$cluster)
}

annotation_colors_list <- list(
  Group = groupcolor, # Define groupcolor
  cluster = cluster_colors
)


# --- 9. calculate Gaps ---
cat("Calculating gaps...\n")
row_gaps <- which(diff(as.numeric(row_annotation_df_sorted$cluster)) != 0)
col_gaps <- which(diff(as.numeric(col_annotation_df_ordered$Group)) != 0)


# --- 10.  Heatmap ---
cat("Generating heatmap... This may take time.\n")
heatmap_body_colors <- colorRampPalette(c("navy", "white", "firebrick3"))(100)

# / (/)
show_row_names <- nrow(heatmap_matrix_final) <= 50 # 50
show_col_names <- ncol(heatmap_matrix_final) <= 100 # 100

pheatmap_plot <- pheatmap(
  heatmap_matrix_final,
  color = heatmap_body_colors,
  annotation_row = row_annotation_df_sorted,
  annotation_col = col_annotation_df_ordered,
  annotation_colors = annotation_colors_list,
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  show_rownames = show_row_names,
  show_colnames = show_col_names,
  gaps_row = row_gaps,
  gaps_col = col_gaps,
  border_color = NA, #  "grey60"
  main = "Gene Expression Heatmap (Z-score Scaled & Capped) by Cluster",
  fontsize = 8,
  fontsize_row = if(show_row_names) 7 else 8, # 
  fontsize_col = if(show_col_names) 7 else 8  # 
)

#  pheatmap 
# print(pheatmap_plot) # 

cat("--- Script End ---\n")

# ---  ---
# 1:  ggsave (If pheatmap  ggplot  grob)
# library(ggplot2)
# ggsave("Final_Heatmap.pdf", plot = pheatmap_plot, width = 10, height = 12) # 

# 2:  pdf()/png() 
pdf("suture_mes_mito_MAGIC_OG3_DEG_cluster_Heatmap_10.pdf", width = 10, height = 12)
pheatmap(
  heatmap_matrix_final,
  color = heatmap_body_colors,
  annotation_row = row_annotation_df_sorted,
  annotation_col = col_annotation_df_ordered,
  annotation_colors = annotation_colors_list,
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  show_rownames = show_row_names,
  show_colnames = show_col_names,
  gaps_row = row_gaps,
  gaps_col = col_gaps,
  border_color = NA, #  "grey60"
  main = "Gene Expression Heatmap (Z-score Scaled & Capped) by Cluster",
  fontsize = 8,
  fontsize_row = if(show_row_names) 7 else 8, # 
  fontsize_col = if(show_col_names) 7 else 8  # 
)
dev.off()
```


## 5.3.4 Heatmap for cluster6
Average expression trend in cluster 6 fit with the differnet trend as we observed for different cell percentage 
```{r}
# --- 0.  ---
# rm(list = ls())

# --- 1.  ---
library(pheatmap)
library(dplyr)
library(tibble)
library(RColorBrewer)

cat("--- Script Start ---\n")

# --- !! Define Genes of Interest !! ---
gene_of_interest <- c("mt-Co1", "mt-Co2","mt-Co3", "mt-Atp6", "mt-Cytb", "mt-Nd4","Serpinf1","Snhg18", "Cdk8")
if (!exists("gene_of_interest") || !is.character(gene_of_interest) || length(gene_of_interest) == 0) {
    warning(" 'gene_of_interest' Define")
    gene_of_interest <- c()
} else {
    cat(paste("Genes to label on heatmap:", paste(gene_of_interest, collapse=", "), "\n"))
}

# --- 2.  ---
file_path <- "suture_mes_mito_MAGIC_OG3_DEG_RNA_matrix.csv"
cat(paste("Loading data from:", file_path, "\n"))
if (!file.exists(file_path)) stop("Error: Input CSV file not found.")
df_reordered_raw <- read.csv(file = file_path, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE, row.names = 1)
cat("Initial Data Check...\n")
print(paste("Dimensions:", paste(dim(df_reordered_raw), collapse=" x ")))

# --- 3. Ensure ---
cat("Preparing numeric matrix...\n")
if (!all(sapply(df_reordered_raw, is.numeric))) {
    warning("Some data columns were not numeric. Attempting conversion...")
    original_rownames <- rownames(df_reordered_raw)
    df_ready_for_scaling <- suppressWarnings(as.matrix(sapply(df_reordered_raw, function(x) as.numeric(as.character(x)))))
    rownames(df_ready_for_scaling) <- original_rownames
    if(!is.numeric(df_ready_for_scaling)) stop("Failed to convert non-numeric columns.")
    rows_all_na <- apply(df_ready_for_scaling, 1, function(r) all(is.na(r)))
     if(any(rows_all_na)){
         warning("Removing rows that became all NA after conversion.")
         df_ready_for_scaling <- df_ready_for_scaling[!rows_all_na, , drop=FALSE]
         if(nrow(df_ready_for_scaling) == 0) stop("All rows became NA after conversion.")
     }
} else {
    df_ready_for_scaling <- as.matrix(df_reordered_raw)
}
cat("--- Prepared Matrix Check ---\n")
print(paste("Dimensions:", paste(dim(df_ready_for_scaling), collapse=" x ")))

# --- 4. Z-score standardization and upper/lower limit setting (with name protection) ---
cat("\n--- Applying Z-score Scaling and Capping ---\n")
x_matrix <- df_ready_for_scaling
original_rownames <- rownames(x_matrix)
original_colnames <- colnames(x_matrix)
if(is.null(original_rownames) || length(original_rownames) != nrow(x_matrix)) stop("Invalid row names before scaling.")
cat("Performing row-wise Z-score scaling...\n")
scaled_matrix_values <- t(scale(t(x_matrix)))
if(!identical(dim(scaled_matrix_values), dim(x_matrix))) stop("Dimension mismatch after scaling.")
rownames(scaled_matrix_values) <- original_rownames
colnames(scaled_matrix_values) <- original_colnames
scaled_matrix <- scaled_matrix_values
cat("Restored names after scaling.\n")
nan_rows_mask <- apply(scaled_matrix, 1, function(row) any(is.nan(row)))
valid_genes_after_scaling <- rownames(scaled_matrix)[!nan_rows_mask]
if (any(nan_rows_mask)) {
  num_nan_rows <- sum(nan_rows_mask)
  warning(sprintf("Removing %d rows with zero variance (NaN).", num_nan_rows))
  scaled_matrix <- scaled_matrix[!nan_rows_mask, , drop = FALSE]
  if(nrow(scaled_matrix) == 0) stop("All rows removed due to zero variance.")
  valid_genes_after_scaling <- rownames(scaled_matrix)
} else { cat("No zero variance rows found.\n") }
cap_limit <- 4
scaled_matrix[scaled_matrix > cap_limit] <- cap_limit
scaled_matrix[scaled_matrix < -cap_limit] <- -cap_limit
heatmap_matrix_prepared <- scaled_matrix
cat("Capping applied.\n")
cat("--- Matrix Check After Scaling/Capping ---\n")
print(paste("Dimensions:", paste(dim(heatmap_matrix_prepared), collapse=" x ")))


# --- 5.  &  Cluster ---
cat("\n--- Preparing Row Annotation and Filtering ---\n")
# ---  'gene_cluster_map' ---
loaded_assignments_df <- read.csv("suture_mes_mito_MAGIC_OG3_DEG_clusterinfo_10.csv", stringsAsFactors = FALSE)
gene_cluster_map <- setNames(loaded_assignments_df$Cluster, loaded_assignments_df$Gene)
cat("Loaded gene cluster map from file.\n")
# --- End Loading ---

# ---  Cluster ---
target_cluster <- 6  # *** Ensure Cluster ***
cat(paste("Targeting Cluster:", target_cluster, "\n"))

#  ()
common_genes <- intersect(rownames(heatmap_matrix_prepared), names(gene_cluster_map))
if(length(common_genes) < nrow(heatmap_matrix_prepared)) {
    warning("Filtering matrix to genes present in cluster map.")
    heatmap_matrix_prepared <- heatmap_matrix_prepared[common_genes, , drop=FALSE]
}
if(length(common_genes) == 0) stop("No common genes between matrix and cluster map.")

all_row_annotation_df <- data.frame(
  row.names = common_genes,
  cluster = factor(gene_cluster_map[common_genes])
)
all_row_annotation_df <- na.omit(all_row_annotation_df) # Remove cluster 
heatmap_matrix_prepared <- heatmap_matrix_prepared[rownames(all_row_annotation_df), , drop=FALSE] # 

# ---  Cluster ---
row_annotation_target <- all_row_annotation_df %>%
    filter(cluster == target_cluster)

if(nrow(row_annotation_target) == 0) stop(paste("No genes found for Cluster", target_cluster))
cat(paste("Found", nrow(row_annotation_target), "genes in Cluster", target_cluster, "\n"))

# 
heatmap_matrix_target <- heatmap_matrix_prepared[rownames(row_annotation_target), , drop = FALSE]

# ---  Cluster  () ---
row_order_target <- order(rownames(row_annotation_target))
# row_annotation_target_sorted <- row_annotation_target[row_order_target, , drop = FALSE] # because
heatmap_matrix_target_sorted <- heatmap_matrix_target[row_order_target, , drop = FALSE]


# --- 6. () ---
heatmap_matrix_final <- heatmap_matrix_target_sorted # 


# --- 7.  ---
cat("Preparing column annotation and sorting columns...\n")
desired_group_order <- c("WT_PF","Runx2_PF","KO_PF","DM_PF",
                         "WT_SAG","Runx2_SAG","KO_SAG","DM_SAG")
groupcolor <- c(WT_PF="#FF5733", Runx2_PF="#FFC300", KO_PF="#FF4081", DM_PF="#7B1FA2",
                WT_SAG='#4CAF50', Runx2_SAG='#2196F3', KO_SAG='#795548', DM_SAG='#2C427E')
if(!identical(names(groupcolor), desired_group_order)) warning("Names of groupcolor do not match desired_group_order!")

sample_names <- colnames(heatmap_matrix_final)
group_mapping <- gsub("_\\d+$", "", sample_names)
if (!all(group_mapping %in% desired_group_order)) warning("Some sample names did not map to expected groups.")

col_annotation_df <- data.frame(Group = factor(group_mapping, levels = desired_group_order))
rownames(col_annotation_df) <- sample_names

ordered_sample_indices <- order(factor(group_mapping, levels = desired_group_order))
ordered_sample_names <- sample_names[ordered_sample_indices]

heatmap_matrix_final <- heatmap_matrix_final[, ordered_sample_names, drop = FALSE]
col_annotation_df_ordered <- col_annotation_df[ordered_sample_names, , drop = FALSE]


# --- 8. Define (Define) ---
cat("Defining annotation colors (only for columns)...\n")
annotation_colors_list <- list(
  Group = groupcolor
)


# --- 9. calculate Gaps (calculate) ---
cat("Calculating column gaps...\n")
col_gaps <- which(diff(as.numeric(col_annotation_df_ordered$Group)) != 0)


# --- 10.  Heatmap ( Workaround ) ---
cat("Generating heatmap for Cluster", target_cluster, "using workaround for labels...\n")
heatmap_body_colors <- colorRampPalette(c("navy", "white", "firebrick3"))(100)

# ---  ---
final_rownames <- rownames(heatmap_matrix_final) # Cluster 6 
row_labels <- rep("", length(final_rownames))
genes_to_label <- intersect(gene_of_interest, final_rownames)
indices_to_label <- match(genes_to_label, final_rownames)
indices_to_label <- indices_to_label[!is.na(indices_to_label)]
if(length(indices_to_label) > 0){
    row_labels[indices_to_label] <- final_rownames[indices_to_label]
    cat(paste("Prepared", sum(row_labels != ""), "labels for display.\n"))
} else { cat("No genes of interest found in Cluster", target_cluster, "to label.\n") }

# ---  ---
heatmap_matrix_display <- heatmap_matrix_final
if(length(row_labels) != nrow(heatmap_matrix_display)) stop("Length mismatch: row_labels vs matrix rows.")
rownames(heatmap_matrix_display) <- row_labels # 
cat("\n--- Final Detailed Check of Matrix to be Plotted ---\n")
cat("1. Matrix: heatmap_matrix_display\n")
print(paste("Dimensions:", paste(dim(heatmap_matrix_display), collapse=" x ")))

cat("\n2. Rownames of heatmap_matrix_display:\n")
current_rownames <- rownames(heatmap_matrix_display)
print("Head of current rownames:")
print(head(current_rownames))
print("Tail of current rownames:")
print(tail(current_rownames))

non_empty_count <- sum(current_rownames != "")
empty_count <- sum(current_rownames == "")
print(paste("Total rows:", length(current_rownames)))
print(paste("Non-empty rownames (should be labeled):", non_empty_count))
print(paste("Empty rownames:", empty_count))

if (non_empty_count > 0) {
    cat("Sample of non-empty rownames that SHOULD be displayed:\n")
    print(head(current_rownames[current_rownames != ""]))
} else if (length(gene_of_interest) > 0 && length(intersect(gene_of_interest, rownames(heatmap_matrix_final))) > 0) {
    # If
    warning("Row names for display matrix unexpectedly became all empty strings!")
}

cat("\n3. Column names head:\n")
print(head(colnames(heatmap_matrix_display))) # Ensure

cat("--- End Final Detailed Check ---\n")

# --- pheatmap  (Workaround version) ---
# Ensure
pheatmap_plot <- pheatmap(
  heatmap_matrix_display,      # 
  color = heatmap_body_colors,
  # annotation_row = NA,       # Remove
  annotation_col = col_annotation_df_ordered,
  annotation_colors = annotation_colors_list, #  Group 
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  show_rownames = TRUE,          # ***  TRUE ***
  show_colnames = FALSE,
  gaps_col = col_gaps,
  # labels_row = NA,             # *** Remove ***
  border_color = NA,
  main = paste("Cluster", target_cluster, "Heatmap (Trying to Show Labels via Rownames)"),
  fontsize = 8,
  fontsize_row = 8               # Ensure > 0
)
# ---  ---
pdf_filename <- paste0("Cluster", target_cluster, "_Heatmap_Labeled_NoRowAnno.pdf")
pdf(pdf_filename, width = 8, height = 3) # 
print(pheatmap_plot) #  PDF
dev.off()
cat(paste("Saved heatmap to:", pdf_filename, "\n"))
```


# 6 Feature Plot for DEs in OG3
```{r}
gc()
rm(list=ls())
.libPaths(c("/home/liuhuan/rpackage/", "/usr/local/lib/R/site-library"))
library(ggplot2)
library(Seurat)
library(SeuratObject)
library(RColorBrewer)
library(dplyr)
library(magrittr)
suture_mes_mito_MAGIC <- readRDS(file = "./SeuratObject/suture_mes_mito_MAGIC_harmony_renamed_20250420.rds")
suture <- readRDS(file = "./SeuratObject/suture_harmony_celltype_20230328.rds")

suture_OG <-readRDS(file = "./SeuratObject/suture_mes_mito_MAGIC_OG_0430.rds")
```
### 6.1 UMAP plot for celltype

```{r,draft plot for celltype}
DimPlot(suture, reduction = "umap", label = T, group.by = "celltype")
plotc <- DimPlot(suture, reduction = "umap", label = T, group.by = "celltype")
ggsave("./OutputFigure/suture_umap_celltype.pdf", plot = plotc, width = 7, height = 5)
```
### 6.2 mes plot for genes
```{r}
DefaultAssay(suture_mes_mito_MAGIC) <- "MAGIC_SCT"
DefaultAssay(suture_OG) <- "MAGIC_SCT"

```


```{r, ibsp,fig.height=3, fig.width=20}

FeaturePlot(suture_mes_mito_MAGIC, features = c("Ibsp"),
            cols = c("grey85",brewer.pal(9,"YlOrRd")),
            split.by = "orig.ident",
            pt.size = 0.1,
            label=T, repel=T)
```
```{r, Igfbp5,fig.height=3, fig.width=20}

FeaturePlot(suture_mes_mito_MAGIC, features = c("Igfbp5"),
            cols = c("grey85",brewer.pal(9,"YlOrRd")),
            split.by = "orig.ident",
            pt.size = 0.1,
            label=T, repel=T)
```
```{r, Igfbp5,fig.height=9, fig.width=20}

FeaturePlot(suture_mes_mito_MAGIC, features = c("mt-Co1","mt-Atp6","mt-Nd4"),
            cols = c("grey85",brewer.pal(9,"YlOrRd")),
            split.by = "orig.ident",
            pt.size = 0.1,
            label=T, repel=T)
```
```{r, Igfbp5,fig.height=9, fig.width=20}

FeaturePlot(suture_mes_mito_MAGIC, features = c("Sqstm1","Nsd3","Atf4"),
            cols = c("grey85",brewer.pal(9,"YlOrRd")),
            split.by = "orig.ident",
            pt.size = 0.1,
            label=T, repel=T)
```

```{r, ibsp,fig.height=3, fig.width=20}

FeaturePlot(suture_mes_mito_MAGIC, features = c("Tomm20"),
            cols = c("grey85",brewer.pal(9,"YlOrRd")),
            split.by = "orig.ident",
            pt.size = 0.1,
            label=T, repel=T)
```


```{r, ibsp,fig.height=3, fig.width=20}

FeaturePlot(suture_mes_mito_MAGIC, features = c("Cdk8"),
            cols = c("grey85",brewer.pal(9,"YlOrRd")),
            split.by = "orig.ident",
            pt.size = 0.1,
            label=T, repel=T)
```

```{r, ibsp,fig.height=3, fig.width=20}
# Define
new_order <- c("WT_PF", "Runx2_PF", "KO_PF", "DM_PF", 
               "WT_SAG", "Runx2_SAG", "KO_SAG", "DM_SAG")

#  orig.ident 
suture_OG@meta.data$orig.ident <- factor(
  suture_OG@meta.data$orig.ident,
  levels = new_order
)


FeaturePlot(suture_OG, features = c("Cdk8"),
            cols = c("grey85",brewer.pal(9,"YlOrRd")),
            split.by = "orig.ident",
            pt.size = 0.1,
            label=T, repel=T)

plotc1<- FeaturePlot(suture_OG, features = c("Cdk8"),
            cols = c("grey85",brewer.pal(9,"YlOrRd")),
            split.by = "orig.ident",
            pt.size = 0.1,
            label=T, repel=T)

ggsave("./OutputFigure/suture_mes_OG_Cdk8.pdf", plot = plotc1, width = 24, height = 3)
```



# X R session info


```{r}
session_info_file <- "./OutputFigure/session_info.txt"

# Capture comprehensive environment details
capture.output(
  {
    cat("=== Essential Session Information ===\n")
    print(sessionInfo())
    cat("\n\n=== Loaded Namespace Packages ===\n")
    print(sessionInfo()$loadedOnly)
  },
  file = session_info_file
)


```


